<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>派翠克技術手札</title><link>https://patrick85081.github.io/</link><description>Recent content on 派翠克技術手札</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Tue, 24 May 2022 16:01:20 +0800</lastBuildDate><atom:link href="https://patrick85081.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>docker container log 上限設定</title><link>https://patrick85081.github.io/posts/2022-05-24-docker-container-log-limit/</link><pubDate>Tue, 24 May 2022 16:01:20 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-05-24-docker-container-log-limit/</guid><description>最近在linux測試機上發現，不知為何硬碟空間就滿了，最後查證是docker container log 吃滿，而且吃到11GB都不會清除，查了一下原來需要設定log檔案限制。
默認情況容器的 stdout 和 stderr 都會被寫入 /var/lib/docker/containers/[container-id]/[container-id]-json.log 的 json 文件。如果一直無人理會，這個文件最終會佔用大量的磁盤空間。
// 檢查方式 du -Sh /var/lib/docker/containers 修改設定檔案 【需要注意的是：设置的日志大小规则，只对新建的容器有效】
/etc/docker/daemon.json
{ // docker 網卡 IP &amp;#34;bip&amp;#34;: &amp;#34;169.254.0.1/24&amp;#34;, // docker log format &amp;#34;log-driver&amp;#34;: &amp;#34;json-file&amp;#34;, &amp;#34;log-opts&amp;#34;: { // single file size &amp;#34;max-size&amp;#34;: &amp;#34;1m&amp;#34;, // log file count &amp;#34;max-file&amp;#34;: &amp;#34;3&amp;#34; } } 重啟 Docker 下列方法：二擇一 systemctl restart docker.service /etc/init.d/docker restart 觀察結果 檔案被限制在 1M &amp;amp; 檔案數量維持在 3個內
這個檔案就是 docker log 檔案</description></item><item><title>Windows Port Forwarding</title><link>https://patrick85081.github.io/posts/2022-04-18-windows-udp-port-forwarding/</link><pubDate>Mon, 18 Apr 2022 13:47:43 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-04-18-windows-udp-port-forwarding/</guid><description>今天來研究Windows平台如何做到 Port Forwarding的功能，將所有的封包進行轉發作業。
使用 Windows 內建的 Port Proxy 功能 只支援TCP協定
// 增加 Port Forwarding netsh interface portproxy add v4tov4 listenport=4001 listenaddress=192.168.36.100 connectport=4001 connectaddress=192.168.36.75 // 刪除 Port Forwarding netsh interface portproxy delete v4tov4 listenport=4001 listenaddress=192.168.36.100 // 清除所有的 Port Forwarding netsh interface portproxy reset // 顯示目前的 Forwarding 設定 netsh interface portproxy show v4tov4 Listen on ipv4: Connect to ipv4: Address Port Address Port --------------- ---------- --------------- ---------- 192.168.36.100 4001 192.168.36.90 4001 使用 Windows Server NAT Server 的 Port Mapping 首先先開啟 NAT 伺服器，使用 TCP/UDP Port對應，讓外部使用者可以存取內部伺服器。</description></item><item><title>快速上手 System.Text.Json</title><link>https://patrick85081.github.io/posts/2022-04-12-about-system-text-json/</link><pubDate>Tue, 12 Apr 2022 20:21:21 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-04-12-about-system-text-json/</guid><description>現在有些C#程式使用到Json時，慢慢地從Newtown.Json轉換成System.Text.Json，System.Text.Json有些手法還是需要學習一下。
範例 Json 資料 這是本次範例使用的Json資料
{ // Commit &amp;#34;Field&amp;#34;: { &amp;#34;AA&amp;#34;: 1234, &amp;#34;BB&amp;#34;: &amp;#34;中文&amp;#34;, } } Json Option System.Text.Json在 序列化 與 反序列化 有些 Option 需要注意
序列化 預設不允許註解、不允許 尾端欄位 有逗號 new JsonDocumentOptions { // 允許 Json 註解 CommentHandling = JsonCommentHandling.Skip, // 允許 尾端欄位 有逗號 AllowTrailingCommas = true } 反序列化 預設 沒有開啟中文的編碼，所以有需要輸出中文需要特別設定。 new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping } Utf8JsonWriter / Utf8JsonReader 這是裡面較為低階的處理方式，屬於一次一個節點的處理，JsonConverter會需要此操作，所以還是必須學會。
var stream = new MemoryStream(); var writer = new Utf8JsonWriter(stream, new JsonWriterOptions { Encoder = JavaScriptEncoder.</description></item><item><title>C# 呼叫 C/C++ 函式庫</title><link>https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/</link><pubDate>Sat, 09 Apr 2022 11:04:49 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/</guid><description>很多場景都需要與C/C++ Library溝通做朋友，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。
靜態呼叫 使用C#的DllImport去匯入C語言function，例如在user32.dll中的MessageBox，這時候要先了解裡面的資料型態該如何去對應C#資料型態。
MessageBox在user32.dll宣告長這樣: MessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); 使用C# 呼叫 using System; using System.Runtime.InteropServices; [DllImport(&amp;#34;user32.dll&amp;#34;)] private static extern int MessageBox(IntPtr hWnd, String text, String caption, int type); public static void Main() { MessageBox(IntPtr.Zero, &amp;#34;Text&amp;#34;, &amp;#34;Caption&amp;#34;, 0); } C struct 的對應 還有一種情況，C function中使用的類型不是基本型別，是額外定義的型別，我們也需要定義對應的C# 物件來接收，就拿 Kernal32.dll中的 GetSystemTime來說
void GetSystemTime(LPSYSTEMTIME lpSystemTime); typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds; } SYSTEMTIME, *PSYSTEMTIME; 要呼叫這個function，我們必須定義一個C#的Class和C Struct有一樣的結構，而且成員的順序也需要相同。</description></item><item><title>SQL 批次刪除，資料轉型失敗問題</title><link>https://patrick85081.github.io/posts/2022-03-29-entityframework-batch-delete-cast-not-valid/</link><pubDate>Wed, 30 Mar 2022 13:12:45 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-03-29-entityframework-batch-delete-cast-not-valid/</guid><description>原由 最近碰到一個有去的錯誤，當透過EntityFrameworkPlus 做資料庫資料批次刪除，結果卻回傳InvalidCastException，但是卻只有這個DB才有此問題，這問題真叫人苦惱。
原程式很單純，大致上如下：
dataContext.Employees .Where(e =&amp;gt; e.Year &amp;gt; 30) .Delete(); 結果 結果發現因之前有資料庫除錯上需求，在該資料表加入 Delete Trigger，應該要 Insert 刪除記錄到另一張表，卻寫成資料 Select。
陰錯陽差之下在 Entity Framework Plus 下達刪除命令後，會去抓資料庫回傳的影響資料筆數，卻抓到 Trigger 產生出來的資料，造成使用該資料的第一個Row第一個Column資料，轉型成 影響筆數 （Int32） 才出的錯誤，結案。</description></item><item><title>SQL Server Use SSL</title><link>https://patrick85081.github.io/posts/2022-03-28-sql-server-use-ssl/</link><pubDate>Mon, 28 Mar 2022 21:59:29 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-03-28-sql-server-use-ssl/</guid><description>今天來研究一下，SQL Server如何使用SSL加密連線，保護資料的安全性。
mmc 產生憑證 SQL Server 使用SSL憑證 開啟 SQL Server 組態管理員
強制加密 是：Client 一律使用加密連線 否：由 Client 決定是否加密 增加 NT Service\MSSQLSERVER 使用憑證權限 重啟 SQL Server
Client 連線 Encrypt connection 使用加密連線 (對應連線字串 Encrypt=True)
Trust server certificate 信任憑證 (對應連線字串 TrustServerCertificate=True)
驗證是否加密 使用Wireshark 使用 TDS 過濾 看不到 SQL Batch 就代表加密成功
參考資料 啟用 SQL Server SSL 連線加密</description></item><item><title>Ldap 資料查詢</title><link>https://patrick85081.github.io/posts/2022-03-26-ldap-connection/</link><pubDate>Sat, 26 Mar 2022 15:38:18 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-03-26-ldap-connection/</guid><description>Ldap 連線 之前接手的程式碼是使用DirectoryEntry來做Ldap連線，但一直試不出來Ssl連線，後來查了一下，原來可以使用LdapConnection，這裡來記錄一下它的使用方式。
Nuget 安裝 dotnet add package System.DirectoryServices.Protocol
Simple Bind var ldap = new LdapConnection(&amp;#34;192.168.10.201:389&amp;#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // 登入 ldap.Bind(new NetworkCredential(&amp;#34;Account&amp;#34;, &amp;#34;Password&amp;#34;)); Sasl var ldap = new LdapConnection(&amp;#34;192.168.10.201:389&amp;#34;); // Sasl ldap.AuthType = AuthType.Negotiate; ldap.SessionOptions.ProtocolVersion = 3; //ldap.SessionOptions.Signing = true; //ldap.SessionOptions.Sealing = true; // 登入 ldap.Bind(new NetworkCredential(&amp;#34;Account&amp;#34;, &amp;#34;Password&amp;#34;)); SSL var ldap = new LdapConnection(&amp;#34;192.168.10.201:636&amp;#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // SSL ldap.SessionOptions.SecureSocketLayer = true; // 略過 憑證檢查 ldap.</description></item><item><title>Appium + WindowsApplicationDriver Sample</title><link>https://patrick85081.github.io/posts/2022-02-28-winappdriver-sample/</link><pubDate>Mon, 28 Feb 2022 22:52:33 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-02-28-winappdriver-sample/</guid><description>Selemium 是測試Web UI的測試工具，可以遙控瀏覽器模擬人工行為，達到UI測試功能，Windows Desktop上是否也有此功能，那就是 Appium 了。
環境相依 開啟 Windows 開發者模式 安裝 WinAppDriver 使用管理員權限開啟C:\Program Files (x86)\Windows Application Driver\WinAppDriver.exe
並記錄 http://127.0.0.1:4723/下來，待會測試時需要使用此網址
工具 WinAppDriver UI Recorder 錄製UI操作轉成程式碼或查看XPath 下載並執行WinAppDriver UI Recoder
安裝 Windows 10 SDK inspect.exe可以查看應用程式內控制項代號 C:\Program Files (x86)\Windows Kits\10\bin\10.0.xxxxx.0\x64\inspect.exe
Appium WebDriver 首先先安裝 Appium.WebDriver
dotnet package add Appium.WebDriver
小算盤測試 public class CalculatorTests { private WindowsDriver&amp;lt;WindowsElement&amp;gt; WindowsDriver; [SetUp] public void Setup() { var appiumOptions = new AppiumOptions(){}; // 如果是 UWP 輸入 Packet Id，如果是 Desktop 則輸入exe路徑 appiumOptions.</description></item><item><title>Python Django 基本指令</title><link>https://patrick85081.github.io/posts/2022-02-08-python-django/</link><pubDate>Tue, 08 Feb 2022 15:17:30 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-02-08-python-django/</guid><description>Python &amp;amp; Django 基本指令 虛擬環境 # 建立虛擬環境 py -3 -m venv venv # 進入虛擬環境 .\venv\Scripts\activate.bat # 離開虛擬環境 .\venv\Scripts\deactivate.bat 套件管理 # 安裝套件 pip install &amp;lt;package&amp;gt; # 列出有安裝的套件 pip list # 將環境有安裝的套件匯出到 requirements.txt pip freeze &amp;gt; requirements.txt # 安裝 requirements.txt 上的套件 pip install -r requirements.txt django 專案建立 # 建立 django 專案 （使用第二行） django-admin startproject &amp;lt;ProjectName&amp;gt; py -m django startproject &amp;lt;ProjectName&amp;gt; # 建立 app py manage.py startapp &amp;lt;AppName&amp;gt; # Run Develop Server py manage.</description></item><item><title>EF6 資料庫欄位預設值</title><link>https://patrick85081.github.io/posts/2022-01-24-ef6-sql-default-value/</link><pubDate>Mon, 24 Jan 2022 22:19:36 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-01-24-ef6-sql-default-value/</guid><description>有接觸過SQL的朋友應該都知道資料庫欄位有個功能可以設定預設值，當新增資料時此欄位沒給資料時，資料庫會自動賦予預設值，這個需求再簡單不過了，但是在EF6上解法稍微複雜一些，而且還不能跨資料庫，因為它有部分是調用原始SQL方式，不過這裡先記錄一下方法。
EntityFramework6是一個很不錯的ORM框架，但是它在某些資料庫較為細節的部分有些不夠完善，有些在EntityFrameworkCore都有簡單的解決方法，因為歷史包袱還是要繞些遠路。
方法一 C# 端解決方案 這種方式在SQL端還是沒有預設值，但是使用C#物件屬性預設值的方式，如果以完美主義的角度來說還是不夠。
public class MyEntity { public string Json { get; set; } = &amp;#34;{}&amp;#34;; } 方法二 Entity Framework 6 Default Value For Sql .Net 已經內建 DefaultValueAttribute ，所以我們就不另外建立。
DbContext 增加 Conventions，將DefaultValueAttribute 對應到字串資料上 public class DataContext : DbContext { protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Conventions.Add(new AttributeToColumnAnnotationConvention&amp;lt;DefaultValueAttribute, string&amp;gt;( &amp;#34;SqlDefaultValue&amp;#34;, (p, attribute) =&amp;gt; attribute.SingleOrDefault().Value.ToString())); } } Entity 中增加 DefaultValue，裡面可以增加預設值，除了填寫常數以外，也可以填寫gettime()之類的SQL方法，功能也就更多元。 public class MyEntity { [DefaultValue(&amp;#34;&amp;#39;{}&amp;#39;&amp;#34;)] public string Json { get; set; } = &amp;#34;{}&amp;#34;; } 增加 MigrationSqlGenerator，在新增資料表、修改資料表、新增欄位、修改欄位時去修改預設值，但是移除預設值時會去執行指定的SQL語法。 internal class DefaultValueSqlServerMigrationSqlGenerator : SqlServerMigrationSqlGenerator { private int dropConstraintCount; protected override void Generate(AddColumnOperation addColumnOperation) { SetAnnotatedColumn(addColumnOperation.</description></item><item><title>動態切換 EF6 設定檔中的SQL Provider</title><link>https://patrick85081.github.io/posts/2022-01-19-ef6-configuration-by-code/</link><pubDate>Wed, 19 Jan 2022 22:02:49 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-01-19-ef6-configuration-by-code/</guid><description>我們都知道Entity Framework 6的設定是儲存在 app.config/Web.config，但是如果我想要在程式中動態切換他的SQL Provider時候應該怎麼做呢?
Use Config by file 正常的 app.config / web.config 都有以下設定，記錄著有哪些 SQL Provider，還有連線字串的資訊。
&amp;lt;!-- 必備橋段 --&amp;gt; &amp;lt;entityFramework&amp;gt; &amp;lt;providers&amp;gt; &amp;lt;provider invariantName=&amp;#34;System.Data.SqlClient&amp;#34; type=&amp;#34;System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer&amp;#34; /&amp;gt; &amp;lt;!-- SQLite Provider --&amp;gt; &amp;lt;provider invariantName=&amp;#34;System.Data.SQLite.EF6&amp;#34; type=&amp;#34;System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6&amp;#34; /&amp;gt; &amp;lt;provider invariantName=&amp;#34;System.Data.SQLite&amp;#34; type=&amp;#34;System.Data.SQLite.EF6.SQLiteProviderServices, System.Data.SQLite.EF6&amp;#34; /&amp;gt; &amp;lt;/providers&amp;gt; &amp;lt;/entityFramework&amp;gt; &amp;lt;!-- 選配橋段 --&amp;gt; &amp;lt;connectionStrings&amp;gt; &amp;lt;add name=&amp;#34;DefaultConnection&amp;#34; connectionString=&amp;#34;data source=lab.db&amp;#34; providerName=&amp;#34;System.Data.SQLite&amp;#34; /&amp;gt; &amp;lt;/connectionStrings&amp;gt; Use DbConfiguration by code 實作 DbConfiguration，等同於 xml entityFramework/providers/provider 設定 有三個步驟
註冊 EF Provider Factory 註冊 EF Provider Service 註冊 Db Provider Factory public class SqliteConfig : DbConfiguration { public SqliteConfig() { // Register EF Provider Factory SetProviderFactory(&amp;#34;System.</description></item><item><title>AvaloniaUI 踩坑紀錄</title><link>https://patrick85081.github.io/posts/2021-12-01-avaloniaui-first/</link><pubDate>Wed, 01 Dec 2021 19:45:10 +0800</pubDate><guid>https://patrick85081.github.io/posts/2021-12-01-avaloniaui-first/</guid><description>前言 從.Net Framework到.Net，微軟的C#終於可以跨平台，跑在Linux、Docker Container，但是桌面應用程式WinForm、WPF依然只能Windows，然而有個開源項目Avalonia卻是以WPF的風格做出跨平台的桌面應用程式，雖然在各方面都還不構成熟，我們期待它未來的發展。
環境建置 Dotnet 樣板 下載樣板 Avalonia Dotnet Template
安裝樣板
dotnet new –install [path-to-repository]
Avalonia 樣板 範本名稱 簡短名稱 語言 標記 Avalonia .NET Core App avalonia.app [C#],F# ui/xaml/avalonia/avaloniaui Avalonia .NET Core MVVM App avalonia.mvvm [C#],F# ui/xaml/avalonia/avaloniaui Avalonia UserControl avalonia.usercontrol [C#],F# ui/xaml/avalonia/avaloniaui Avalonia Window avalonia.window [C#],F# ui/xaml/avalonia/avaloniaui Avalonia TemplatedControl avalonia.</description></item><item><title>Dhcp 協議</title><link>https://patrick85081.github.io/posts/2021-05-25-dhcp-protocol/</link><pubDate>Tue, 25 May 2021 23:02:52 +0800</pubDate><guid>https://patrick85081.github.io/posts/2021-05-25-dhcp-protocol/</guid><description>DHCP (Dynamic Host Configuration Protocol)
DHCP為動態主機設定協定，為了避免發生內網上的IP地址重複發生IP衝突，每當有網路設備要連線時會向DHCP伺服器請求IP地址，由DHCP Server找出尚未使用的IP地址分配給網路設備，同一個區網盡可能只配置一個DHCP Server，如果需要多個DHCP服務器需要分別設定不衝突的派發範圍，避免發生IP地址衝突的情況。
Dhcp V4 Client Method Direction DHCP Client Discover (尋找區網內的DHCP Server) -&amp;gt; DHCP Client Offer (DHCP 分配一組IP地址與租約 給 客戶端) &amp;lt;- DHCP Client Request (告訴DHCP，我使用你的地址) -&amp;gt; DHCP Client Ack (DHCP回應此地址租約正式生效) &amp;lt;- DHCP 封包觀察 DHCP Discover
設備剛上線沒有IP地址，所以Source IP為0.0.0.0，不知道DHCP在哪裡，所以是廣播封包
DHCP Offer
DHCP 伺服器收到請求(192.168.1.200)，發送一組IP為192.168.1.150給目標MAC地址
DHCP Request</description></item><item><title>ARP 協議</title><link>https://patrick85081.github.io/posts/2021-05-19-arp-protocol/</link><pubDate>Wed, 19 May 2021 10:58:28 +0800</pubDate><guid>https://patrick85081.github.io/posts/2021-05-19-arp-protocol/</guid><description>說明 ARP全名為Address Resolution Protocol （位置發現協議），在網路鏈路層上傳遞封包都需要知道目的的Mac Address，但在網路曾是使用網路層地止IP Address，所以需要透過ARP協議去廣播，詢問對方的Mac Address。
ARP 運作 ARP運作方式相當簡單，一個是ARP 詢問（ARP Request），一個是ARP 答復（ARP Reply）。
透過發送ARP Request去廣過，區域網路上的所有電腦，詢問IP地址的MAC地址是多少，如果收到網播的電腦不是這個IP地址就會忽略它，但收到的電腦剛好是這個IP地址，就會進行ARP Reply回應自己的MAC地址。由於路由器會阻擋區域網路中的廣播封包，所以ARP只能詢問同一個網路。
每一台電腦上都有自己的ARP快取，同一個地址一段時間只會詢問一次，避免廣播風暴的發生，另外也可以使用靜態ARP設定，這樣就不需要詢問，但是這兩種方式只要重新開機都會清空。
ARP 指令 查詢ARP記錄 可以利用 arp -a 指令來查詢電腦中所儲存的ARP記錄
C:\&amp;gt; arp -a Interface: 192.168.1.128 --- 0x10 Internet Address Physical Address Type 192.168.1.1 c0-06-c3-3b-5b-ec dynamic 192.168.1.255 ff-ff-ff-ff-ff-ff static 224.0.0.2 01-00-5e-00-00-02 static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 新增靜態APR記錄 利用 arp -s &amp;lt;IP地址&amp;gt; &amp;lt;MAC地址&amp;gt; 新增靜態地址
C:\&amp;gt; arp -s 203.74.205.42 00-00-e8-97-73-86 刪除APR記錄 可利用 arp -d 刪除全部或 arp -d &amp;lt;IP地址&amp;gt; 刪除指定IP的方式。</description></item><item><title>IIS 使用 LocalDB 問題</title><link>https://patrick85081.github.io/posts/2021-05-07-iis-localdb/</link><pubDate>Fri, 07 May 2021 23:28:13 +0800</pubDate><guid>https://patrick85081.github.io/posts/2021-05-07-iis-localdb/</guid><description>開發時候使用LocalDB使用得很順手，因此將網站放到本機的IIS時，也會想要沿用開發時候使用的LocalDb，原本以為是很單純的一件事，沒想到後面有這麼多的問題。
當IIS下 直接使用 LocalDB，出現 Local DB Runtime Error 出現以下錯誤
A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name is correct and that SQL Server is configured to allow remote connections. (provider: SQL Network Interfaces, error: 50 - Local Database Runtime error occurred. Cannot create an automatic instance. See the Windows Application event log for error details.</description></item><item><title>Halcon Frame Grabber</title><link>https://patrick85081.github.io/posts/2021-02-03-halcon-frame-grabber/</link><pubDate>Wed, 03 Feb 2021 20:06:07 +0800</pubDate><guid>https://patrick85081.github.io/posts/2021-02-03-halcon-frame-grabber/</guid><description>Halcon是一套付費的影像處裡函式庫，為了方便測試裡面的影像處理功能，所以她有整合了一些相機取像的功能，Halcon將軟體切成四層：
軟體架構 Halcon Application
這裡代表我們開發的軟體，或者HDevlop測試工具
Halcon Image Processing Library
這裡是我們使用的Halcon函示庫，就是halcon.dll
Halcon xyz Frame Grabber Interface
Halcon做的一套中間取像的抽象層，也就是我們軟體界所說的 interface
Frame Grabber Driver &amp;amp; SDK
這裡是實作取像功能的實作，整合不同廠牌的相機驅動，為了方便我們可以使用
使用方式 選擇實作介面 也可以使用自動偵測，判斷電腦本身可以使用哪些取像實作 連結相機 這裡展示就只使用File方式，指定資料夾內的影像，模擬相機取像的效果。 相機參數設定 這裡可以設定相機參數，例如使用GenICamTL，這裡就會出現GenICamTL參數 使用範本產生程式碼 HDevelop Demo C# Demo 對於寫相機SDK有經驗的朋友可能會說，相機SDK怎麼可以沒有取像Callback方法呢?
其實Halcon也有提供，但經過測試發現不是所有的實作都支援Callback方法，但如果只是要取像測試的話，這樣單張取像的方式應該也就夠用了。
Halcon Frame Grabber Callback 測試過 GenICamTL 有支援
var grabber = new HFramegrabber( &amp;#34;GenICamTL&amp;#34;, 0, 0, 0, 0, 0, 0, &amp;#34;progressive&amp;#34;, -1, &amp;#34;default&amp;#34;, -1, &amp;#34;false&amp;#34;, &amp;#34;default&amp;#34;, _deviceName, 0, -1); grabber.</description></item><item><title>PLC 讀寫資料轉換</title><link>https://patrick85081.github.io/posts/2020-11-21-plc-data-read-write/</link><pubDate>Sat, 21 Nov 2020 20:04:23 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-21-plc-data-read-write/</guid><description>當要跟PLC做資料交換溝通時，常常會碰到一個問題，PLC是16bit的系統，傳遞字串與數字時都需要經過一些處理，高位元與低位元的byte處理，這裡做個紀錄以免忘記。
字串類型 PLC一個Device為16bit，一個字元為8bit，所以可放兩個字元。
寫入字串 我們需要將一串文字兩個字元一組轉成int，寫入int陣列進去PLC。 程式的邏輯應該長這樣
一個int = 高位元文字(char[1]) * 256 + 低位元文字(char[0])
來，我們來看程式碼：
// 輸入的字串 string text = &amp;#34;Patrick&amp;#34;; int[] datas = ( // 總共有幾組 from num in Enumerable.Range(0, (text.Length + 1)) // 每一組的起始 index let startIndex = num * 2 // 低位元 let low = text.ElementAtOrDefault(startIndex) // 高位元 let heigh = text.ElementAtOrDefault(startIndex + 1) select height * 256 + low ) .ToArray(); 讀入字串 接下來我們需要將int 陣列轉回字串，一個int為兩個字元，程式的虛擬碼長這樣：</description></item><item><title>WinForm 內部對話框，標題拖曳功能</title><link>https://patrick85081.github.io/posts/2020-11-20-winform-drag-inner-dialog-panel/</link><pubDate>Fri, 20 Nov 2020 20:12:59 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-20-winform-drag-inner-dialog-panel/</guid><description>開發 WinForm 時，要做到WinForm內部對話框，而且又可以按住標題拖曳的效果，可以透過Panel手刻出對話框，透過WinAPI做到拖曳效果。
public partial class Form1 : Form { [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern bool ReleaseCapture(); [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam); public Form1() { InitializeComponent(); } private void DialogTitle_MouseDown(object sender, MouseEventArgs e) { if (e.Button == MouseButtons.Left) { //釋放鼠標捕捉 ReleaseCapture(); //發送左鍵點擊的消息至該視窗 SendMessage(FrocePanel1.Handle, 0xA1, 0x02, 0); } } } 範例程式碼</description></item><item><title>Halcon 常用的Function</title><link>https://patrick85081.github.io/posts/2020-11-18-halcon-note/halcon-note/</link><pubDate>Wed, 18 Nov 2020 22:18:52 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-18-halcon-note/halcon-note/</guid><description>影像分割 固定二值化 // P3, P4 =&amp;gt; 二值化閥值區間 threshold(GrayImage, DarkArea, 0, 128) 直方圖自動二值化 // P3 =&amp;gt; Sigma 高斯運算 平滑算子 auto_threshold(GrayImage, DarkArea, 8.0) P.S. 可用 gray_histo or gen_region_histo 查看直方圖
自動全局二值化 利用直方圖像素分佈，例如最大類間方插法或平滑直方圖法
// P3 =&amp;gt; 二值化的方法 // max_separability 直方圖中最大的可分性分割 // smooth_histo 平滑直方圖 // P4 =&amp;gt; 取 亮部 light 還是 暗部 dark // P5 =&amp;gt; 輸出 自動二值化使用的閥值 binary_threshold(GrayImage, DarkArea, &amp;#39;max_separability&amp;#39;, &amp;#39;dark&amp;#39;, UsedThreshold) 局部閥值分割法 適用於無法用單一灰階分割情況，如背景複雜，亮暗不均
步驟
套用平滑濾波器 使用dyn_threshold 比較 原始圖像 與 套用平滑濾波器 後的影像差異，將差異大於設定值的點找出來 // P3 =&amp;gt; 輸出的閥值區域 // P4 =&amp;gt; Offset 值，比較後大於該值將被提取出來 // P5 =&amp;gt; 哪個區域 // light 原圖 &amp;gt;= 平滑後 + Offset // dark 原圖 &amp;lt;= 平滑後 - Offset // equal (平滑後 + Offset) &amp;lt; 原圖 &amp;lt; (平滑後 - Offset) // not_equal (平滑後 + Offset) &amp;gt;= 原圖 Or 原圖 &amp;gt;= (平滑後 - Offset) dyn_threshold(Image, ImageMean, RegionDynThresh, 4, &amp;#39;not_equal&amp;#39;) Var_Threshold // P3, P4 =&amp;gt; Mask 長寬 // P5 =&amp;gt; 標準差因子 // P6 =&amp;gt; 絕對閥值 // P7 =&amp;gt; dark, light, equal, not_equal var_threshold(Image, Region, 15, 15, 0.</description></item><item><title>PLC 連線設定</title><link>https://patrick85081.github.io/posts/2020-11-08-plc-emulator-communication/</link><pubDate>Sun, 08 Nov 2020 22:37:59 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-08-plc-emulator-communication/</guid><description>這裡來記錄一下PLC模擬器的設定方式，以及C#連接PLC的程式碼。
Communication 設定教學 模擬器連線設定 設定 Station Number PLC類型 選擇模擬器 GX Simulator2 設定連線名稱 完成結果 透過網路連線設定 選擇 網路以及連線模式 設定IP 設定模式 以及 CPU類型 連線名稱 完成結果 GX Work2 啟動模擬器 開啟新專案 開始 模擬 C# 開發方式 加入參考 MITSUBISHI ActMulti Control 參考清單 Coding var easyIf = new ActEasyIF(); easyIf.ActLogicalStationNumber = 1; if (easyIf.Open() != 0) throw new Exception(&amp;#34;連線失敗&amp;#34;); // Read Block (D0 ~ D49) var buffer = new int[50]; easyIf.</description></item><item><title>三菱 MR-MT-2200 馬達脈波控制器</title><link>https://patrick85081.github.io/posts/2020-11-03-mr-mt-2200/</link><pubDate>Tue, 03 Nov 2020 20:40:52 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-03-mr-mt-2200/</guid><description>這裡來介紹一下三菱MT-2200 馬達脈波控制器使用方式。
市面上的馬達驅動器分為兩種，一種是脈波(Plus)與資料通訊的訊號傳 遞方式，脈波型是屬於通用型，不同廠牌的控制器、馬達驅動器與馬達只要送相對應的脈波都可以互相控制，但是資料通訊就不一樣了，各家都有各家的通訊方式無法互通，換句話說全部都只能使用同一家的設備，資料通訊的好處是時脈可以比脈波通訊快很多，而且佈線走線都很簡單而且訊號品質也會比脈波好，三菱走的是SSCNET III/H光纖通訊。
當需要同時控制脈波型與通訊型的馬達時，正常的情況只能分別接兩種運動控制卡分別控制，MT-2000系列目的就是讓脈波型的馬達驅動器經過通訊卡(MT-2010)，也可以走SSCNET III/H通訊，優點是可以減少一張脈波型運動控制卡成本。
MT-2010 為通訊卡
可以將MT-2000系列的裝置使用SSCNET III/H通訊
MT-2100 為數位IO卡
MT-2200 為脈波控制卡
可以透過此卡操控脈波型的馬達
MT-2300 為類比IO卡
MT-2400 為Encoder 輸入卡
安裝 使用工業卡扣的設計
區塊 一張MT-2010通訊卡最多只能接四個模組(設備)，通訊卡加上底下的設備稱為一個區塊(Block)。
MT-2200 脈波控制卡 脈波控制卡的最大特色是，他擁有兩組脈波IO訊號，可以分別選擇脈波要當 輸入還是輸出功能。
設定 軸號/站號 在MT-2200上頭有兩個旋轉開關，由此設定 SSCNET III/H的設備編號
模式設定 MT-2200有兩種模式，一種稱為站模式(Station Mode)和軸模式(Axis Mode)
站模式
此模式就像把MT-2200當成脈波控制的IO卡，自行控制脈波的輸出。
軸模式 (推薦)
此模式就像把MT-2200當成運動控制卡來做控制，軟體面來說就跟操控一般馬達沒有兩樣。
前面有說到 脈波控制卡有兩組脈波IO，可以分別選擇要做 輸入還是輸出使用，對應馬達控制的話就是要 輸出馬達訊號 還是 Encoder回授訊號接收，換句話說要讓 MT-2200 輸出脈波給兩個馬達，還是 輸出脈波給一個馬達並接收一個Encoder訊號。
接線方式 把 MT-2010通訊卡當作一般的三菱驅動器接線即可。</description></item><item><title>Halcon 影像記憶體洩漏</title><link>https://patrick85081.github.io/posts/2020-10-06-halcon-image-leak/</link><pubDate>Tue, 06 Oct 2020 20:25:42 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-10-06-halcon-image-leak/</guid><description>問題情境 假設因相機或機構問題，相機取到的影像需做簡易影像旋轉和翻轉功能。我們來做幾個簡單的實驗，驗證影像記憶體的佔用情況。
需求：
彩色黑白轉換 水平翻轉 垂直翻轉 旋轉 跑一千次觀察記憶體使用量 方案一 HImage依序做完所有的影像處理。 方案二 HImage 每做完一個影像處裡，就Dispose前一張影像` 結論 Halcon 每做完一次影像處理，其實是做資料複製，記憶體中的資料從一張影像會變成兩張影像，做越多次處裡記憶體的佔用也就越大，所以記得每次處理完都需要做影像銷毀。
附上範例程式碼，執行前請先安裝Halcon 12</description></item><item><title>Camera Link 學習筆記</title><link>https://patrick85081.github.io/posts/2016-06-01-about-camera-link/</link><pubDate>Wed, 01 Jun 2016 19:31:40 +0800</pubDate><guid>https://patrick85081.github.io/posts/2016-06-01-about-camera-link/</guid><description>這是我對Camera Link的學習心得，其實了解Camera Link的硬體架構後會發現其實它很單純，而且改良以前Anlog影像擷取卡相機遇到的一些問題，使用起來更為便利，了解Camera Link後對於之後的 CoaXPress 應該也會更快上手。
Camera Link 由來 當初國家半導體公司(National Semicndmtor)開發設計出Channel Link的相關技術，主要實體層架構是以LVDS規範為基礎，作為平面顯示等關聯性產品的解決途徑。後來，這種技術也被延伸應用於進行資料傳輸的一般用途。
Camera Link規格是由AIA協會（Automate Imaging Association）定義，該協會則是由工業用攝像機、信號線、影像擷取卡製造商所組成的產業組織。
長度限制：
數據傳輸距離受到限制、最長只能達到10m，可透過光纖訊號轉換器將訊號轉換成光纖，使得傳輸距離更遠。
影像擷取卡供電：
Mini Camera Link的誕生，相機縮小的同時逐漸出現擷取卡供電PoCL的趨勢，只要使使用原本的線材即可達成
信號規格：
Camera Link採用低電壓差分信號（LVDS）
低電壓差分傳輸是一種信號傳輸的技術，區別於傳統的一根信號線一根地線的做法，差分傳輸在這兩根線上都傳輸信號，這兩個信號的振幅相等，相位相反。在這兩根線上的傳輸的信號就是差分信號。信號接收端比較這兩個電壓的差值來判斷發送端發送的是邏輯0 還是邏輯1 。在電路板上，差分走線必須是等長、等寬、緊密靠近、且在同一層面的兩根線。
支援多台相機：
影像擷取卡中也有可以連接多台相機的產品 Camera Link標準提供三種組態 Base組態 (一組連接器)
包含一組傳送器/接收器，24 bits的視訊資料分為A、B、C三個8-bit連接埠，在使用20~85 MHz時脈之下，影像資料傳輸率可高達2.04 Gbps。
Medium組態 (兩組連接器)
增加第二組傳送器/接收器對，影像資料位元倍增為48 bits（8-bit連接埠亦倍增為六個：A、B、C、D、E、F）、資料傳輸率倍增為4.08 Gbps。
Full組態 (兩組連接器)
再次增加影像資料位元為64 bits，使用八個8-bit連接埠：A、B、C、D、E、F、G、H，提高影像資料傳輸率為5.44 Gbps。
Extended-Full (兩組連接器)
使用Full組態的硬體配置，將Base、Medium、Full影像同步訊號(LVAL、FVAL、DVAL、SPARE)做了調整與壓縮，三組的同步訊號其實只用的到一組，使用空閒的兩組同步訊號再加上一組空閒的8 bits硬體，這樣就可以再擠出16 bits出來傳遞影像，使得影像資料位元達到80 bits，使用十個8-bit連接埠：A、B、C、D、E、F、G、H、I、J，提高影像資料傳輸率為6.</description></item><item><title>Search Results</title><link>https://patrick85081.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://patrick85081.github.io/search/</guid><description/></item></channel></rss>