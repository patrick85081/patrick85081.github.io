[{"categories":null,"contents":"原由 最近碰到一個有去的錯誤，當透過EntityFrameworkPlus 做資料庫資料批次刪除，結果卻回傳InvalidCastException，但是卻只有這個DB才有此問題，這問題真叫人苦惱。\n原程式很單純，大致上如下：\ndataContext.Employees .Where(e =\u0026gt; e.Year \u0026gt; 30) .Delete(); 結果 結果發現因之前有資料庫除錯上需求，在該資料表加入 Delete Trigger，應該要 Insert 刪除記錄到另一張表，卻寫成資料 Select。\n陰錯陽差之下在 Entity Framework Plus 下達刪除命令後，會去抓資料庫回傳的影響資料筆數，卻抓到 Trigger 產生出來的資料，造成使用該資料的第一個Row第一個Column資料，轉型成 影響筆數 （Int32） 才出的錯誤，結案。\n","permalink":"https://patrick85081.github.io/posts/2022-03-29-entityframework-batch-delete-cast-not-valid/","tags":["SQL","EntityFramework"],"title":"SQL 批次刪除，資料轉型失敗問題"},{"categories":null,"contents":"今天來研究一下，SQL Server如何使用SSL加密連線，保護資料的安全性。\nmmc 產生憑證 SQL Server 使用SSL憑證 開啟 SQL Server 組態管理員\n 強制加密  是：Client 一律使用加密連線 否：由 Client 決定是否加密    增加 NT Service\\MSSQLSERVER 使用憑證權限 重啟 SQL Server\nClient 連線   Encrypt connection 使用加密連線 (對應連線字串 Encrypt=True)\n  Trust server certificate 信任憑證 (對應連線字串 TrustServerCertificate=True)\n  驗證是否加密 使用Wireshark 使用 TDS 過濾 看不到 SQL Batch 就代表加密成功\n參考資料 啟用 SQL Server SSL 連線加密\n","permalink":"https://patrick85081.github.io/posts/2022-03-28-sql-server-use-ssl/","tags":["SQL Server","SSL"],"title":"SQL Server Use SSL"},{"categories":null,"contents":"Ldap 連線 之前接手的程式碼是使用DirectoryEntry來做Ldap連線，但一直試不出來Ssl連線，後來查了一下，原來可以使用LdapConnection，這裡來記錄一下它的使用方式。\nNuget 安裝  dotnet add package System.DirectoryServices.Protocol\n Simple Bind var ldap = new LdapConnection(\u0026#34;192.168.10.201:389\u0026#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); Sasl var ldap = new LdapConnection(\u0026#34;192.168.10.201:389\u0026#34;); // Sasl ldap.AuthType = AuthType.Negotiate; ldap.SessionOptions.ProtocolVersion = 3; //ldap.SessionOptions.Signing = true; //ldap.SessionOptions.Sealing = true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); SSL var ldap = new LdapConnection(\u0026#34;192.168.10.201:636\u0026#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // SSL ldap.SessionOptions.SecureSocketLayer = true; // 略過 憑證檢查 ldap.SessionOptions.VerifyServerCertificate = (con, cert) =\u0026gt; true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); Sasl + SSL var ldap = new LdapConnection(\u0026#34;192.168.10.201:636\u0026#34;); // Sasl ldap.AuthType = AuthType.Negotiate; ldap.SessionOptions.ProtocolVersion = 3; // SSL ldap.SessionOptions.SecureSocketLayer = true; // 略過 憑證檢查 ldap.SessionOptions.VerifyServerCertificate = (con, cert) =\u0026gt; true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;));  資料查詢 var response = ldap.SendRequest(new SearchRequest( \u0026#34;DC=pixis,DC=com\u0026#34;, \u0026#34;(objectclass=domain)\u0026#34;, SearchScope.Subtree) ) as SearchResponse; foreach (var entry in response.Entries.Cast\u0026lt;SearchResultEntry\u0026gt;()) { var distinguishedName = entry.DistinguishedName; var rawData = entry.Attributes[\u0026#34;name\u0026#34;].GetValues(typeof(byte[]))[0] as byte[]; var name = Encoding.Default.GetString(rawData); Console.WriteLine(); Console.WriteLine(distinguishedName); Console.WriteLine(name); } ","permalink":"https://patrick85081.github.io/posts/2022-03-26-ldap-connection/","tags":["Ldap"],"title":"Ldap 資料查詢"},{"categories":null,"contents":"影像分割 固定二值化 // P3, P4 =\u0026gt; 二值化閥值區間 threshold(GrayImage, DarkArea, 0, 128) 直方圖自動二值化 // P3 =\u0026gt; Sigma 高斯運算 平滑算子 auto_threshold(GrayImage, DarkArea, 8.0)  P.S. 可用 gray_histo or gen_region_histo 查看直方圖\n 自動全局二值化  利用直方圖像素分佈，例如最大類間方插法或平滑直方圖法\n // P3 =\u0026gt; 二值化的方法 // max_separability 直方圖中最大的可分性分割 // smooth_histo 平滑直方圖 // P4 =\u0026gt; 取 亮部 light 還是 暗部 dark // P5 =\u0026gt; 輸出 自動二值化使用的閥值 binary_threshold(GrayImage, DarkArea, \u0026#39;max_separability\u0026#39;, \u0026#39;dark\u0026#39;, UsedThreshold) 局部閥值分割法  適用於無法用單一灰階分割情況，如背景複雜，亮暗不均\n 步驟\n 套用平滑濾波器 使用dyn_threshold 比較 原始圖像 與 套用平滑濾波器 後的影像差異，將差異大於設定值的點找出來  // P3 =\u0026gt; 輸出的閥值區域 // P4 =\u0026gt; Offset 值，比較後大於該值將被提取出來 // P5 =\u0026gt; 哪個區域 // light 原圖 \u0026gt;= 平滑後 + Offset // dark 原圖 \u0026lt;= 平滑後 - Offset // equal (平滑後 + Offset) \u0026lt; 原圖 \u0026lt; (平滑後 - Offset) // not_equal (平滑後 + Offset) \u0026gt;= 原圖 Or 原圖 \u0026gt;= (平滑後 - Offset) dyn_threshold(Image, ImageMean, RegionDynThresh, 4, \u0026#39;not_equal\u0026#39;) Var_Threshold // P3, P4 =\u0026gt; Mask 長寬 // P5 =\u0026gt; 標準差因子 // P6 =\u0026gt; 絕對閥值 // P7 =\u0026gt; dark, light, equal, not_equal var_threshold(Image, Region, 15, 15, 0.2, 35, \u0026#39;darkk\u0026#39;) Char_Threshold char_threshold(Imge, Image, Characters, 6, 95, Threshold) Dual_Threshold dual_threshold(Imge, RegionCrossings, MinSize, MinGray, Threshold) 區域生長法 RegiongRowing  將灰階相近的像素合併\n // P3, P4 =\u0026gt; 矩形區域長寬 (奇數) // P5 =\u0026gt; 灰階差的分割標準 // P6 =\u0026gt; 輸出區域的最小像素 regiongrowing(Image, Regions, 1, 1, 3.0, 100)  Bayer RG8 to Halcon Halcon CfaToRgb  將單通道彩色，轉換成三通道\n // cfa_to_rgb — Convert a single-channel color filter array image into an RGB image. // CFAType: \u0026#39;bayer_bg\u0026#39;, \u0026#39;bayer_gb\u0026#39;, \u0026#39;bayer_gr\u0026#39;, \u0026#39;bayer_rg\u0026#39; // Interpolation: \u0026#39;bilinear\u0026#39;, \u0026#39;bilinear_dir\u0026#39;, \u0026#39;bilinear_enhanced\u0026#39; static void HOperatorSet.CfaToRgb(HObject CFAImage, out HObject RGBImage, HTuple CFAType, HTuple interpolation) Basler Grab result to Halcon\n图像Bayer格式介绍以及Bayer插值原理CFA\n图像bayer格式介绍以及bayer插值原理\n","permalink":"https://patrick85081.github.io/posts/2022-03-22-halcon-note/halcon-note/","tags":["Halcon"],"title":"Halcon 常用的Function"},{"categories":null,"contents":"前言 從.Net Framework到.Net，微軟的C#終於可以跨平台，跑在Linux、Docker Container，但是桌面應用程式WinForm、WPF依然只能Windows，然而有個開源項目Avalonia卻是以WPF的風格做出跨平台的桌面應用程式，雖然在各方面都還不構成熟，我們期待它未來的發展。\n環境建置 Dotnet 樣板   下載樣板 Avalonia Dotnet Template\n  安裝樣板\n   dotnet new –install [path-to-repository]\n  Avalonia 樣板     範本名稱 簡短名稱 語言 標記     Avalonia .NET Core App avalonia.app [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia .NET Core MVVM App avalonia.mvvm [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia UserControl avalonia.usercontrol [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia Window avalonia.window [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia TemplatedControl avalonia.templatedcontrol [C#] ui/xaml/avalonia/avaloniaui   Avalonia Resource Dictionary avalonia.resource  ui/xaml/avalonia/avaloniaui   Avalonia Styles avalonia.styles  ui/xaml/avalonia/avaloniaui     參考資料 Avalonia Hello World  IDE擴充套件   Visual Studio Avalonia for Visual Studio\n  JetBrains Rider\n 加入 Plugin Repository https://plugins.jetbrains.com/plugins/dev/14839  安裝 AvaloniaRider AvaloniaRider     教學文檔 AvaloniaUI Doc\n一起學習 Avalonia\nAvalonia 社群資料整理\nReactiveUI Doc\nreactive progamming dot net\nXAML標記x:Name不能用 開始正常使用後會發現第一個問題，以前在寫WPF時候，幫控制項取變數名稱的x:Name=\u0026quot;MyName\u0026quot;，Window內就可直接調用不管用了\n 第一種方法 (原生) 可以在 Window/UserControl中使用Find\u0026lt;T\u0026gt;(name)取得  this.Find\u0026lt;TextBlock\u0026gt;(\u0026#34;txt\u0026#34;);  第二種方法 改成使用Source Generator的方式來做，需要另外安裝Nuget包XamlNameReferenceGenerator   dotnet add package XamlNameReferenceGenerator\n 套件GitHub : Avalonia.NameGenerator\n 參考資料 Avaloniaui奇怪问题记录之x:Name用不了  MessageBox不見了 在AvaloniaUI裡面沒有MessageBox，大概是只要自己用Window做一做就好所以就沒內建，5這裡有其他人做的簡易MessageBox\n dotnet add package MessageBox.Avalonia\n 套件GitHub : MessageBox.Avalonia\nvar messageBoxStandardWindow = MessageBox.Avalonia.MessageBoxManager .GetMessageBoxStandardWindow( \u0026#34;Title\u0026#34;, \u0026#34;Show MessageBox Content\u0026#34;); await messageBoxStandardWindow.Show(); //ShowDialog(windows); Design DataContext 在 Avalonia 不支援 d:DesignInstance，所以設計時候的DataContext要改寫法\n以前在WPF 可以寫\n\u0026lt;Window d:DataContext=\u0026#34;{d:DesignInstance local:MyDesignViewModel, IsDesignTimeCreatable=true}\u0026#34; \u0026gt; \u0026lt;/Window\u0026gt; 在 Avalonia 要寫\n 方法一 靜態方式取得，需要事先塞好測試資料  \u0026lt;Window d:DataContext=\u0026#34;{x:static local:MyDesignData.MyViewModel}\u0026#34; \u0026gt; \u0026lt;/Window\u0026gt; public class MyDesignData { public static MyViewModel MyViewModel =\u0026gt; new MyViewModel(){ Title = \u0026#34;MyTitle\u0026#34; }; }  方法二 設計時去產生資料，可在View塞資料  \u0026lt;Window \u0026gt; \u0026lt;Design.DataContext\u0026gt; \u0026lt;local:DesignViewModel Title=\u0026#34;MyTitle\u0026#34;/\u0026gt; \u0026lt;/Design.DataContext\u0026gt; \u0026lt;/Window\u0026gt; 參考資料  Design-Time Properties Add support for d:DesignInstance when using d:DataContext in designer #2445 How to set DataContext in own UserControl? #2121   Behavor  dotnet add package Avalonia.Xaml.Behaviors\n 套件GitHub : AvaloniaBehaviors\nEventToCommand \u0026lt;UserControl x:Class=\u0026#34;BehaviorsTestApplication.Views.Pages.EventTriggerBehaviorView\u0026#34; xmlns=\u0026#34;https://github.com/avaloniaui\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:i=\u0026#34;using:Avalonia.Xaml.Interactivity\u0026#34; xmlns:ia=\u0026#34;using:Avalonia.Xaml.Interactions.Core\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:vm=\u0026#34;using:BehaviorsTestApplication.ViewModels\u0026#34; x:CompileBindings=\u0026#34;True\u0026#34; x:DataType=\u0026#34;vm:MainWindowViewModel\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; d:DesignWidth=\u0026#34;600\u0026#34; d:DesignHeight=\u0026#34;450\u0026#34;\u0026gt; \u0026lt;Design.DataContext\u0026gt; \u0026lt;vm:MainWindowViewModel /\u0026gt; \u0026lt;/Design.DataContext\u0026gt; \u0026lt;Grid RowDefinitions=\u0026#34;Auto,Auto\u0026#34;\u0026gt; \u0026lt;TextBox Name=\u0026#34;TextBox\u0026#34; Text=\u0026#34;Hello\u0026#34; Grid.Row=\u0026#34;0\u0026#34; Margin=\u0026#34;5\u0026#34; /\u0026gt; \u0026lt;Button Name=\u0026#34;ChangeProperty\u0026#34; Content=\u0026#34;Change Property\u0026#34; Grid.Row=\u0026#34;1\u0026#34; Margin=\u0026#34;5,0,5,5\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;ia:EventTriggerBehavior EventName=\u0026#34;Click\u0026#34; SourceObject=\u0026#34;{Binding #ChangeProperty}\u0026#34;\u0026gt; \u0026lt;ia:ChangePropertyAction TargetObject=\u0026#34;{Binding #TextBox}\u0026#34; PropertyName=\u0026#34;Text\u0026#34; Value=\u0026#34;World\u0026#34; /\u0026gt; \u0026lt;ia:InvokeCommandAction Command=\u0026#34;{Binding MyCommand}\u0026#34; /\u0026gt; \u0026lt;/ia:EventTriggerBehavior\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/UserControl\u0026gt;  DI ReactiveUI Splat\n替換其他 DI  Autofac   dotnet add package Splat.Autofac\n 來源：Splat.Autofac\n DryIoc   dotnet add package Splat.DryIoc\n 來源：Splat.DryIoc\n Microsoft.Extensions.DependencyInjection   dotnet add Splat.Microsoft.Extensions.DependencyInjection\n 來源：Splat.Microsoft.Extensions.DependencyInjection\n Ninject   dotnet add package Splat.Ninject\n 來源：Splat.Ninject\n SimpleInjector   dotnet add package Splat.SimpleInjector\n 來源：Splat.SimpleInjector\n更換DI後的注意事項 When you replace dependency injection with autofac, showdialog will report an error\n ReactiveUI Route skip\n UI Live Reload 如果要達到 .Net 6 一樣的 Live Reload，可以透過這個涵式庫，基本上是重用ViewModel，但是UI重新產生。\nLive.Avalonia\n現成UI主題套件  Material.Avalonia  Citrus.Avalonia  Avalonia.FuncUI   UI控制項套件  Avalonia.Microcharts   ","permalink":"https://patrick85081.github.io/posts/2022-03-21-avaloniaui-first/","tags":["Avalonia","WPF","MVVM"],"title":"AvaloniaUI 踩坑紀錄"},{"categories":null,"contents":"說明 ARP全名為Address Resolution Protocol （位置發現協議），在網路鏈路層上傳遞封包都需要知道目的的Mac Address，但在網路曾是使用網路層地止IP Address，所以需要透過ARP協議去廣播，詢問對方的Mac Address。\nARP 運作 ARP運作方式相當簡單，一個是ARP 詢問（ARP Request），一個是ARP 答復（ARP Reply）。\n透過發送ARP Request去廣過，區域網路上的所有電腦，詢問IP地址的MAC地址是多少，如果收到網播的電腦不是這個IP地址就會忽略它，但收到的電腦剛好是這個IP地址，就會進行ARP Reply回應自己的MAC地址。由於路由器會阻擋區域網路中的廣播封包，所以ARP只能詢問同一個網路。\n每一台電腦上都有自己的ARP快取，同一個地址一段時間只會詢問一次，避免廣播風暴的發生，另外也可以使用靜態ARP設定，這樣就不需要詢問，但是這兩種方式只要重新開機都會清空。\nARP 指令 查詢ARP記錄 可以利用 arp -a 指令來查詢電腦中所儲存的ARP記錄\nC:\\\u0026gt; arp -a Interface: 192.168.1.128 --- 0x10 Internet Address Physical Address Type 192.168.1.1 c0-06-c3-3b-5b-ec dynamic 192.168.1.255 ff-ff-ff-ff-ff-ff static 224.0.0.2 01-00-5e-00-00-02 static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 新增靜態APR記錄 利用 arp -s \u0026lt;IP地址\u0026gt; \u0026lt;MAC地址\u0026gt; 新增靜態地址\nC:\\\u0026gt; arp -s 203.74.205.42 00-00-e8-97-73-86 刪除APR記錄 可利用 arp -d 刪除全部或 arp -d \u0026lt;IP地址\u0026gt; 刪除指定IP的方式。\nC:\\\u0026gt; arp -d 192.168.28.36 ARP 攻擊 由於APR的機制會去詢問網路上的設備，有詢問就會有欺騙，使用者的電腦和路由器都有各自的ARP資料，會互相記錄對方的IP與MAC地址，駭客攻擊方會發ARP指令給雙方，讓雙方的APR資料中的MAC地址都變成駭客電腦地址，駭客就會收到雙方所有的封包資料。\n應對方式 只要不使用http、ftp、telnet等這類以明文傳送的協定，改使用https、sftp、ssh等這類經過加密過的協定，就算封包經過駭客手中，也無法解析裡面資料。\n","permalink":"https://patrick85081.github.io/posts/2022-03-19-arp-protocol/","tags":["ARP","Network"],"title":"ARP 協議"},{"categories":null,"contents":"","permalink":"https://patrick85081.github.io/search/","tags":null,"title":"Search Results"}]