[{"categories":null,"contents":"這些年累積下來的經驗，很多場景都需要與C/C++ Library溝通，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。\n靜態呼叫 使用C#的DllImport去匯入C語言function，例如在user32.dll中的MessageBox，這時候要先了解裡面的資料型態該如何去對應C#資料型態。\n MessageBox在user32.dll宣告長這樣:  MessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);  使用C# 呼叫  using System; using System.Runtime.InteropServices; [DllImport(\u0026#34;user32.dll\u0026#34;)] private static extern int MessageBox(IntPtr hWnd, String text, String caption, int type); public static void Main() { MessageBox(IntPtr.Zero, \u0026#34;Text\u0026#34;, \u0026#34;Caption\u0026#34;, 0); } C struct 的對應 還有一種情況，C function中使用的類型不是基本型別，是額外定義的型別，我們也需要定義對應的C# 物件來接收，就拿 Kernal32.dll中的 GetSystemTime來說\nvoid GetSystemTime(LPSYSTEMTIME lpSystemTime); typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds; } SYSTEMTIME, *PSYSTEMTIME; 要呼叫這個function，我們必須定義一個C#的Class和C Struct有一樣的結構，而且成員的順序也需要相同。\nusing System; using System.Runtime.InteropServices; [StructLayout(LayoutKind.Sequential)] public class SystemTime { public ushort year; public ushort month; public ushort weekday; public ushort day; public ushort hour; public ushort minute; public ushort second; public ushort millisecond; } [DllImport(\u0026#34;Kernel32.dll\u0026#34;)] public static extern void GetSystemTime(SystemTime st); public static void Main() { SystemTime t = new SystemTime(); GetSystemTime(t); Console.WriteLine(t.Year); } 這裡有一個網站可以查詢常用的 Windows API 怎麼對應 C#的寫法。\nPInvoke.Net\n 動態呼叫 還有一種作法可以執行的時候才動態去連結指定的function，這種作法寫起來較為麻煩，但是適合的場景為硬體SDK同時提供 x86和 x64的 C API，那我們要包裝成C#時可以動態根據程式架構去連結/調用相對應的API，將讀進來的C function用相對應的C# delegate(function point)來接收，使用時只要呼叫delegate就可以。\n[DllImport(\u0026#34;kernel32\u0026#34;, CharSet = CharSet.Unicode, SetLastError = true)] static extern IntPtr LoadLibrary(string lpFileName); [DllImport(\u0026#34;kernel32\u0026#34;, SetLastError = true)] static extern bool FreeLibrary(IntPtr hModule); [DllImport(\u0026#34;kernel32\u0026#34;, CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = false)] static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName); // 定義對應的 C Function 的 函式指標 delegate void DelegateGetSystemTime(SystemTime st); void Main(string args[]) { // 讀取 C dll  var lib = LoadLibrary(\u0026#34;Kernel32.dll\u0026#34;); // load function to c# function point (delegate)  var getSystemTime = (DelegateGetSystemTime) Marshal.GetDelegateForFunctionPointer( GetProcAddress(lib, \u0026#34;GetSystemTime\u0026#34;), typeof(DelegateGetSystemTime)); // 調用  SystemTime tt = new SystemTime(); getSystemTime(tt); // 釋放 C dll  FreeLibrary(lib); }  查詢 C function的 EntryPoint 通常 C function的方法名稱就是EntryPoint，所以DllImport沒有指定EntryPoint時就會使用方法名稱作為EntryPoint，但是筆者這裡也有碰過硬體廠商提供的C API沒有遵守這個規則，去做對應時候要額外指定EntryPoint，偏偏說明書又沒有告訴你它的EntryPoint，筆者沒有寫過C語言，裡面的原因沒有深入去了解，不過有一套工具可以去查詢C function對應的EntryPoint，它叫做Dependencies。\n利用Dendencies開啓C dll後，可以看到這個dll相依其他的dll，還有他的function清單，就像前面說的一般的function都會跟EntryPoint相同。 這時候按下右鍵，Undecoderate C++ Function取消。 所有的function就原形畢露了，EntryPoint是 ? 開頭，@@YAHPAXPAE@Z 結尾。 這個時候就能成功的對應function了。\n[DllImport(\u0026#34;****.dll\u0026#34;, EntryPoint = \u0026#34;?****_12GPIO_SetValue@@YAHPAXDE@Z\u0026#34;, SetLastError = true, CharSet = CharSet.Unicode)] private static extern int ****_12GPIO_SetValue(IntPtr hdrv, int GPIO_Num, bool val);  實際寫一個 C++ Library 來讓 C# 呼叫 讓我們實際寫一個 C++ Library來讓 C# 呼叫，這樣就能了解到雙方的溝通原理。\n  新增 C++ Win32專案   選擇程式類型   設定專案 CLR 支援   實際寫一個 C++ Library\n宣告C++物件 Calculate\n  // Calculate.h #pragma once class Calculate { public: Calculate(); int Addition(int a, int b);//¥[ªk  int Subtraction(int a, int b);//´îªk  void RegisterCallback(void(*callback)(int, int, int, int)); }; // Calculate.cpp #include \u0026#34;Calculate.h\u0026#34;#include \u0026lt;stdio.h\u0026gt; Calculate::Calculate() { } int Calculate::Addition(int a, int b) { return a + b; } int Calculate::Subtraction(int a, int b) { return a - b; } void Calculate::RegisterCallback(void(*callback)(int, int, int, int)) { callback(1, 2, 3, 4); }  建立 C 函式 風格的包裝\n由於 C# PInvoke無法直接使用C++物件，所以需要包裝成C語言風格的方式，創建物件、銷毀物件、其他方法、註冊Callback等等需要另外包裝。  // ForExternCall.cpp #ifdef TESTDLL_EXPORTS //同專案名稱，只是後面固定為_EXPORTS #define TestDll_API __declspec(dllexport) //請注意！正確的是Export要亮起 #else #define TestDll_API __declspec(dllimport) #endif  #include \u0026#34;Calculate.h\u0026#34; extern \u0026#34;C\u0026#34; TestDll_API Calculate* CreateInstance() { return new Calculate(); } extern \u0026#34;C\u0026#34; TestDll_API void DisposeInstance(Calculate* instance) { if (instance != nullptr) { delete instance; instance = nullptr; } } extern \u0026#34;C\u0026#34; TestDll_API int Add(Calculate* instance, int a, int b) {\t//宣告在function內，只有該function能使用 \treturn instance-\u0026gt;Addition(a, b); } extern \u0026#34;C\u0026#34; TestDll_API int Sub(Calculate* instance, int a, int b) { //宣告在function內，只有該function能使用 \treturn instance-\u0026gt;Subtraction(a, b); } extern \u0026#34;C\u0026#34; TestDll_API void RegisterCallback(Calculate* instance, void(*callback)(int, int, int, int)) { return instance-\u0026gt;RegisterCallback(callback); }  最後做完的專案結構會類似這樣   實際C#物件包裝使用\n由於原本物件導向的方式被拆成，函數式的形式，所以最後需要利用C#包裝回物件導向的形式。  public class Calculate : IDisposable { //傳入和傳出的型態格式必須同ForExternCall.cpp內的設置！！ [DllImport(\u0026#34;TestDll\u0026#34;, EntryPoint = \u0026#34;CreateInstance\u0026#34;)] private static extern IntPtr CreateInstance(); [DllImport(\u0026#34;TestDll\u0026#34;, EntryPoint = \u0026#34;DisposeInstance\u0026#34;)] private static extern void DisposeInstance(IntPtr instance); //我將dll檔放到D:，然後設置進入點 [DllImport(\u0026#34;TestDll.dll\u0026#34;, EntryPoint = \u0026#34;Add\u0026#34;)] private static extern int Add(IntPtr instance, int a, int b); //也可以不設置進入點，但函數名稱必須相同 [DllImport(\u0026#34;TestDll.dll\u0026#34;, EntryPoint =\u0026#34;Sub\u0026#34;)] private static extern int Sub(IntPtr instance, int a, int b); [DllImport(\u0026#34;TestDll\u0026#34;, EntryPoint = \u0026#34;RegisterCallback\u0026#34;)] private static extern void RegisterCallback(IntPtr instance, Callback callback); public delegate void Callback(int a, int b, int c, int d); IntPtr instance = IntPtr.Zero; public Calculate() { instance = CreateInstance(); } public int Add(int a, int b) { return Add(instance, a, b); } public int Sub(int a, int b) { return Sub(instance, a, b); } public void RegisterCallback(Callback callback) { RegisterCallback(instance, callback); } protected virtual void Dispose(bool bDisposing) { if (this.instance != IntPtr.Zero) { // Call the DLL Export to dispose this class  DisposeInstance(this.instance); this.instance = IntPtr.Zero; } if (bDisposing) { // No need to call the finalizer since we\u0026#39;ve now cleaned  // up the unmanaged memory  GC.SuppressFinalize(this); } } public void Dispose() { Dispose(true); } ~Calculate() { Dispose(false); } } 範例程式 CSharpCallCPluseDll\n參考資料 C#呼叫Native DLLs (P/Invoke)\nC++ 製作DLL給C#使用\n","permalink":"https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/","tags":["PInvoke","WindowsAPI"],"title":"C# 呼叫 C/C++ 函式庫"},{"categories":null,"contents":"原由 最近碰到一個有去的錯誤，當透過EntityFrameworkPlus 做資料庫資料批次刪除，結果卻回傳InvalidCastException，但是卻只有這個DB才有此問題，這問題真叫人苦惱。\n原程式很單純，大致上如下：\ndataContext.Employees .Where(e =\u0026gt; e.Year \u0026gt; 30) .Delete(); 結果 結果發現因之前有資料庫除錯上需求，在該資料表加入 Delete Trigger，應該要 Insert 刪除記錄到另一張表，卻寫成資料 Select。\n陰錯陽差之下在 Entity Framework Plus 下達刪除命令後，會去抓資料庫回傳的影響資料筆數，卻抓到 Trigger 產生出來的資料，造成使用該資料的第一個Row第一個Column資料，轉型成 影響筆數 （Int32） 才出的錯誤，結案。\n","permalink":"https://patrick85081.github.io/posts/2022-03-29-entityframework-batch-delete-cast-not-valid/","tags":["SQL","EntityFramework"],"title":"SQL 批次刪除，資料轉型失敗問題"},{"categories":null,"contents":"今天來研究一下，SQL Server如何使用SSL加密連線，保護資料的安全性。\nmmc 產生憑證 SQL Server 使用SSL憑證 開啟 SQL Server 組態管理員\n 強制加密  是：Client 一律使用加密連線 否：由 Client 決定是否加密    增加 NT Service\\MSSQLSERVER 使用憑證權限 重啟 SQL Server\nClient 連線   Encrypt connection 使用加密連線 (對應連線字串 Encrypt=True)\n  Trust server certificate 信任憑證 (對應連線字串 TrustServerCertificate=True)\n  驗證是否加密 使用Wireshark 使用 TDS 過濾 看不到 SQL Batch 就代表加密成功\n參考資料 啟用 SQL Server SSL 連線加密\n","permalink":"https://patrick85081.github.io/posts/2022-03-28-sql-server-use-ssl/","tags":["SQL Server","SSL"],"title":"SQL Server Use SSL"},{"categories":null,"contents":"Ldap 連線 之前接手的程式碼是使用DirectoryEntry來做Ldap連線，但一直試不出來Ssl連線，後來查了一下，原來可以使用LdapConnection，這裡來記錄一下它的使用方式。\nNuget 安裝  dotnet add package System.DirectoryServices.Protocol\n Simple Bind var ldap = new LdapConnection(\u0026#34;192.168.10.201:389\u0026#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); Sasl var ldap = new LdapConnection(\u0026#34;192.168.10.201:389\u0026#34;); // Sasl ldap.AuthType = AuthType.Negotiate; ldap.SessionOptions.ProtocolVersion = 3; //ldap.SessionOptions.Signing = true; //ldap.SessionOptions.Sealing = true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); SSL var ldap = new LdapConnection(\u0026#34;192.168.10.201:636\u0026#34;); ldap.AuthType = AuthType.Basic; ldap.SessionOptions.ProtocolVersion = 3; // SSL ldap.SessionOptions.SecureSocketLayer = true; // 略過 憑證檢查 ldap.SessionOptions.VerifyServerCertificate = (con, cert) =\u0026gt; true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;)); Sasl + SSL var ldap = new LdapConnection(\u0026#34;192.168.10.201:636\u0026#34;); // Sasl ldap.AuthType = AuthType.Negotiate; ldap.SessionOptions.ProtocolVersion = 3; // SSL ldap.SessionOptions.SecureSocketLayer = true; // 略過 憑證檢查 ldap.SessionOptions.VerifyServerCertificate = (con, cert) =\u0026gt; true; // 登入 ldap.Bind(new NetworkCredential(\u0026#34;Account\u0026#34;, \u0026#34;Password\u0026#34;));  資料查詢 var response = ldap.SendRequest(new SearchRequest( \u0026#34;DC=pixis,DC=com\u0026#34;, \u0026#34;(objectclass=domain)\u0026#34;, SearchScope.Subtree) ) as SearchResponse; foreach (var entry in response.Entries.Cast\u0026lt;SearchResultEntry\u0026gt;()) { var distinguishedName = entry.DistinguishedName; var rawData = entry.Attributes[\u0026#34;name\u0026#34;].GetValues(typeof(byte[]))[0] as byte[]; var name = Encoding.Default.GetString(rawData); Console.WriteLine(); Console.WriteLine(distinguishedName); Console.WriteLine(name); } ","permalink":"https://patrick85081.github.io/posts/2022-03-26-ldap-connection/","tags":["Ldap"],"title":"Ldap 資料查詢"},{"categories":null,"contents":"Selemium 是測試Web UI的測試工具，可以遙控瀏覽器模擬人工行為，達到UI測試功能，Windows Desktop上是否也有此功能，那就是 Appium 了。\n環境相依  開啟 Windows 開發者模式   安裝 WinAppDriver   使用管理員權限開啟C:\\Program Files (x86)\\Windows Application Driver\\WinAppDriver.exe\n並記錄 http://127.0.0.1:4723/下來，待會測試時需要使用此網址\n 工具  WinAppDriver UI Recorder 錄製UI操作轉成程式碼或查看XPath   下載並執行WinAppDriver UI Recoder\n  安裝 Windows 10 SDK inspect.exe可以查看應用程式內控制項代號   C:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.xxxxx.0\\x64\\inspect.exe\n Appium WebDriver 首先先安裝 Appium.WebDriver\n dotnet package add Appium.WebDriver\n 小算盤測試 public class CalculatorTests { private WindowsDriver\u0026lt;WindowsElement\u0026gt; WindowsDriver; [SetUp] public void Setup() { var appiumOptions = new AppiumOptions(){}; // 如果是 UWP 輸入 Packet Id，如果是 Desktop 則輸入exe路徑  appiumOptions.AddAdditionalCapability(\u0026#34;app\u0026#34;, \u0026#34;Microsoft.WindowsCalculator_8wekyb3d8bbwe!App\u0026#34;); // 連接 WindowDriver Url  WindowsDriver = new WindowsDriver\u0026lt;WindowsElement\u0026gt;(new Uri(\u0026#34;http://127.0.0.1:4723\u0026#34;), appiumOptions); WindowsDriver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(3); WindowsDriver.Manage().Window.Maximize(); } [Test] public void CalculatorTest() { WindowsDriver.Keyboard.SendKeys(\u0026#34;2\u0026#34;); WindowsDriver.Keyboard.SendKeys(\u0026#34;+\u0026#34;); WindowsDriver.Keyboard.SendKeys(\u0026#34;3\u0026#34;); WindowsDriver.Keyboard.SendKeys(\u0026#34;=\u0026#34;); WindowsDriver.FindElementByAccessibilityId(\u0026#34;CalculatorResults\u0026#34;) .Text .Should() .Be(\u0026#34;Display is 5\u0026#34;); } [TearDown] public void TearDown() { WindowsDriver.Quit(); WindowsDriver.Dispose(); } } 範例程式\n參考資料 Appium + WinAppDriver 測試 Windows 桌面應用程式 UI\n","permalink":"https://patrick85081.github.io/posts/2022-02-28-winappdriver-sample/","tags":["Appium","WindowsAppDriver"],"title":"Appium + WindowsApplicationDriver Sample"},{"categories":null,"contents":"Python \u0026amp; Django 基本指令 虛擬環境 # 建立虛擬環境 py -3 -m venv venv # 進入虛擬環境 .\\venv\\Scripts\\activate.bat # 離開虛擬環境 .\\venv\\Scripts\\deactivate.bat 套件管理 # 安裝套件 pip install \u0026lt;package\u0026gt; # 列出有安裝的套件 pip list # 將環境有安裝的套件匯出到 requirements.txt pip freeze \u0026gt; requirements.txt # 安裝 requirements.txt 上的套件 pip install -r requirements.txt django 專案建立 # 建立 django 專案 （使用第二行） django-admin startproject \u0026lt;ProjectName\u0026gt; py -m django startproject \u0026lt;ProjectName\u0026gt; # 建立 app py manage.py startapp \u0026lt;AppName\u0026gt; # Run Develop Server py manage.py runserver 0.0.0.0:8000 檔案結構 | manage.py\t# Django管理腳本，創建應用、資料庫通訊、啟動開發伺服器 | +---Catalog\t## Start App | | admin.py | | apps.py | | models.py\t### Model | | tests.py | | views.py\t### Controller | | __init__.py | | | \\---migrations\t# ORM 資料庫 Migrations 的地方 | __init__.py | \\---MySite\t## Start Project | asgi.py | settings.py\t# 網站配置，資料庫設定等等 | urls.py\t# 網站 Router 對應，Url對應的View | wsgi.py\t# Django應用和網路服務器之間的通訊 | __init__.py | 資料來源 Django 教學 2: 創建一個骨架網站\n","permalink":"https://patrick85081.github.io/posts/2022-02-08-python-django/","tags":["python","django"],"title":"Python Django 基本指令"},{"categories":null,"contents":"前言 從.Net Framework到.Net，微軟的C#終於可以跨平台，跑在Linux、Docker Container，但是桌面應用程式WinForm、WPF依然只能Windows，然而有個開源項目Avalonia卻是以WPF的風格做出跨平台的桌面應用程式，雖然在各方面都還不構成熟，我們期待它未來的發展。\n環境建置 Dotnet 樣板   下載樣板 Avalonia Dotnet Template\n  安裝樣板\n   dotnet new –install [path-to-repository]\n  Avalonia 樣板     範本名稱 簡短名稱 語言 標記     Avalonia .NET Core App avalonia.app [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia .NET Core MVVM App avalonia.mvvm [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia UserControl avalonia.usercontrol [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia Window avalonia.window [C#],F# ui/xaml/avalonia/avaloniaui   Avalonia TemplatedControl avalonia.templatedcontrol [C#] ui/xaml/avalonia/avaloniaui   Avalonia Resource Dictionary avalonia.resource  ui/xaml/avalonia/avaloniaui   Avalonia Styles avalonia.styles  ui/xaml/avalonia/avaloniaui     參考資料 Avalonia Hello World  IDE擴充套件   Visual Studio Avalonia for Visual Studio\n  JetBrains Rider\n 加入 Plugin Repository https://plugins.jetbrains.com/plugins/dev/14839  安裝 AvaloniaRider AvaloniaRider     教學文檔 AvaloniaUI Doc\n一起學習 Avalonia\nAvalonia 社群資料整理\nReactiveUI Doc\nreactive progamming dot net\nXAML標記x:Name不能用 開始正常使用後會發現第一個問題，以前在寫WPF時候，幫控制項取變數名稱的x:Name=\u0026quot;MyName\u0026quot;，Window內就可直接調用不管用了\n 第一種方法 (原生) 可以在 Window/UserControl中使用Find\u0026lt;T\u0026gt;(name)取得  this.Find\u0026lt;TextBlock\u0026gt;(\u0026#34;txt\u0026#34;);  第二種方法 改成使用Source Generator的方式來做，需要另外安裝Nuget包XamlNameReferenceGenerator   dotnet add package XamlNameReferenceGenerator\n 套件GitHub : Avalonia.NameGenerator\n 參考資料 Avaloniaui奇怪问题记录之x:Name用不了  MessageBox不見了 在AvaloniaUI裡面沒有MessageBox，大概是只要自己用Window做一做就好所以就沒內建，5這裡有其他人做的簡易MessageBox\n dotnet add package MessageBox.Avalonia\n 套件GitHub : MessageBox.Avalonia\nvar messageBoxStandardWindow = MessageBox.Avalonia.MessageBoxManager .GetMessageBoxStandardWindow( \u0026#34;Title\u0026#34;, \u0026#34;Show MessageBox Content\u0026#34;); await messageBoxStandardWindow.Show(); //ShowDialog(windows); Design DataContext 在 Avalonia 不支援 d:DesignInstance，所以設計時候的DataContext要改寫法\n以前在WPF 可以寫\n\u0026lt;Window d:DataContext=\u0026#34;{d:DesignInstance local:MyDesignViewModel, IsDesignTimeCreatable=true}\u0026#34; \u0026gt; \u0026lt;/Window\u0026gt; 在 Avalonia 要寫\n 方法一 靜態方式取得，需要事先塞好測試資料  \u0026lt;Window d:DataContext=\u0026#34;{x:static local:MyDesignData.MyViewModel}\u0026#34; \u0026gt; \u0026lt;/Window\u0026gt; public class MyDesignData { public static MyViewModel MyViewModel =\u0026gt; new MyViewModel(){ Title = \u0026#34;MyTitle\u0026#34; }; }  方法二 設計時去產生資料，可在View塞資料  \u0026lt;Window \u0026gt; \u0026lt;Design.DataContext\u0026gt; \u0026lt;local:DesignViewModel Title=\u0026#34;MyTitle\u0026#34;/\u0026gt; \u0026lt;/Design.DataContext\u0026gt; \u0026lt;/Window\u0026gt; 參考資料  Design-Time Properties Add support for d:DesignInstance when using d:DataContext in designer #2445 How to set DataContext in own UserControl? #2121   Behavor  dotnet add package Avalonia.Xaml.Behaviors\n 套件GitHub : AvaloniaBehaviors\nEventToCommand \u0026lt;UserControl x:Class=\u0026#34;BehaviorsTestApplication.Views.Pages.EventTriggerBehaviorView\u0026#34; xmlns=\u0026#34;https://github.com/avaloniaui\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:i=\u0026#34;using:Avalonia.Xaml.Interactivity\u0026#34; xmlns:ia=\u0026#34;using:Avalonia.Xaml.Interactions.Core\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:mc=\u0026#34;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026#34; xmlns:vm=\u0026#34;using:BehaviorsTestApplication.ViewModels\u0026#34; x:CompileBindings=\u0026#34;True\u0026#34; x:DataType=\u0026#34;vm:MainWindowViewModel\u0026#34; mc:Ignorable=\u0026#34;d\u0026#34; d:DesignWidth=\u0026#34;600\u0026#34; d:DesignHeight=\u0026#34;450\u0026#34;\u0026gt; \u0026lt;Design.DataContext\u0026gt; \u0026lt;vm:MainWindowViewModel /\u0026gt; \u0026lt;/Design.DataContext\u0026gt; \u0026lt;Grid RowDefinitions=\u0026#34;Auto,Auto\u0026#34;\u0026gt; \u0026lt;TextBox Name=\u0026#34;TextBox\u0026#34; Text=\u0026#34;Hello\u0026#34; Grid.Row=\u0026#34;0\u0026#34; Margin=\u0026#34;5\u0026#34; /\u0026gt; \u0026lt;Button Name=\u0026#34;ChangeProperty\u0026#34; Content=\u0026#34;Change Property\u0026#34; Grid.Row=\u0026#34;1\u0026#34; Margin=\u0026#34;5,0,5,5\u0026#34;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;ia:EventTriggerBehavior EventName=\u0026#34;Click\u0026#34; SourceObject=\u0026#34;{Binding #ChangeProperty}\u0026#34;\u0026gt; \u0026lt;ia:ChangePropertyAction TargetObject=\u0026#34;{Binding #TextBox}\u0026#34; PropertyName=\u0026#34;Text\u0026#34; Value=\u0026#34;World\u0026#34; /\u0026gt; \u0026lt;ia:InvokeCommandAction Command=\u0026#34;{Binding MyCommand}\u0026#34; /\u0026gt; \u0026lt;/ia:EventTriggerBehavior\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/UserControl\u0026gt;  DI ReactiveUI Splat\n替換其他 DI  Autofac   dotnet add package Splat.Autofac\n 來源：Splat.Autofac\n DryIoc   dotnet add package Splat.DryIoc\n 來源：Splat.DryIoc\n Microsoft.Extensions.DependencyInjection   dotnet add Splat.Microsoft.Extensions.DependencyInjection\n 來源：Splat.Microsoft.Extensions.DependencyInjection\n Ninject   dotnet add package Splat.Ninject\n 來源：Splat.Ninject\n SimpleInjector   dotnet add package Splat.SimpleInjector\n 來源：Splat.SimpleInjector\n更換DI後的注意事項 When you replace dependency injection with autofac, showdialog will report an error\n ReactiveUI Route skip\n UI Live Reload 如果要達到 .Net 6 一樣的 Live Reload，可以透過這個涵式庫，基本上是重用ViewModel，但是UI重新產生。\nLive.Avalonia\n現成UI主題套件  Material.Avalonia  Citrus.Avalonia  Avalonia.FuncUI   UI控制項套件  Avalonia.Microcharts   ","permalink":"https://patrick85081.github.io/posts/2021-12-01-avaloniaui-first/","tags":["Avalonia","WPF","MVVM"],"title":"AvaloniaUI 踩坑紀錄"},{"categories":null,"contents":"DHCP (Dynamic Host Configuration Protocol)\nDHCP為動態主機設定協定，為了避免發生內網上的IP地址重複發生IP衝突，每當有網路設備要連線時會向DHCP伺服器請求IP地址，由DHCP Server找出尚未使用的IP地址分配給網路設備，同一個區網盡可能只配置一個DHCP Server，如果需要多個DHCP服務器需要分別設定不衝突的派發範圍，避免發生IP地址衝突的情況。\n步驟    Client Method Direction DHCP     Client Discover (尋找區網內的DHCP Server) -\u0026gt; DHCP   Client Offer (DHCP 分配一組IP地址與租約 給 客戶端) \u0026lt;- DHCP   Client Request (告訴DHCP，我使用你的地址) -\u0026gt; DHCP   Client Ack (DHCP回應此地址租約正式生效) \u0026lt;- DHCP    封包觀察   DHCP Discover\n設備剛上線沒有IP地址，所以Source IP為0.0.0.0，不知道DHCP在哪裡，所以是廣播封包\n  DHCP Offer\nDHCP 伺服器收到請求(192.168.1.200)，發送一組IP為192.168.1.150給目標MAC地址\n  DHCP Request\nClient端可能同時收到多個Offer指令，這時候Client會採用第一個Offer指令的資料，發送廣播告訴大家自己要採用哪一個Offer。\n並且會再發送GARP測試看看是否有人在使用這組IP，如果發現衝突，則會發送 Decline給DHCP伺服器取消申請，重新再發Discover\n  DHCP Ack\nDHCP 伺服器回應OK，IP地址租約正式開始\n  資料來源 DHCP協定 (ncut.edu.tw)\n","permalink":"https://patrick85081.github.io/posts/2021-05-25-dhcp/","tags":["Dhcp","Network"],"title":"Dhcp 協議"},{"categories":null,"contents":"說明 ARP全名為Address Resolution Protocol （位置發現協議），在網路鏈路層上傳遞封包都需要知道目的的Mac Address，但在網路曾是使用網路層地止IP Address，所以需要透過ARP協議去廣播，詢問對方的Mac Address。\nARP 運作 ARP運作方式相當簡單，一個是ARP 詢問（ARP Request），一個是ARP 答復（ARP Reply）。\n透過發送ARP Request去廣過，區域網路上的所有電腦，詢問IP地址的MAC地址是多少，如果收到網播的電腦不是這個IP地址就會忽略它，但收到的電腦剛好是這個IP地址，就會進行ARP Reply回應自己的MAC地址。由於路由器會阻擋區域網路中的廣播封包，所以ARP只能詢問同一個網路。\n每一台電腦上都有自己的ARP快取，同一個地址一段時間只會詢問一次，避免廣播風暴的發生，另外也可以使用靜態ARP設定，這樣就不需要詢問，但是這兩種方式只要重新開機都會清空。\nARP 指令 查詢ARP記錄 可以利用 arp -a 指令來查詢電腦中所儲存的ARP記錄\nC:\\\u0026gt; arp -a Interface: 192.168.1.128 --- 0x10 Internet Address Physical Address Type 192.168.1.1 c0-06-c3-3b-5b-ec dynamic 192.168.1.255 ff-ff-ff-ff-ff-ff static 224.0.0.2 01-00-5e-00-00-02 static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 新增靜態APR記錄 利用 arp -s \u0026lt;IP地址\u0026gt; \u0026lt;MAC地址\u0026gt; 新增靜態地址\nC:\\\u0026gt; arp -s 203.74.205.42 00-00-e8-97-73-86 刪除APR記錄 可利用 arp -d 刪除全部或 arp -d \u0026lt;IP地址\u0026gt; 刪除指定IP的方式。\nC:\\\u0026gt; arp -d 192.168.28.36 ARP 攻擊 由於APR的機制會去詢問網路上的設備，有詢問就會有欺騙，使用者的電腦和路由器都有各自的ARP資料，會互相記錄對方的IP與MAC地址，駭客攻擊方會發ARP指令給雙方，讓雙方的APR資料中的MAC地址都變成駭客電腦地址，駭客就會收到雙方所有的封包資料。\n應對方式 只要不使用http、ftp、telnet等這類以明文傳送的協定，改使用https、sftp、ssh等這類經過加密過的協定，就算封包經過駭客手中，也無法解析裡面資料。\n Gratuitous ARP 也稱為 免費的ARP、無故的ARP，GARP與一般ARP不同的地方在於，並非想要得到目標IP對應的MAC，而是主機啟動時，發送GARP，請求自己的 IP地址的MAC，就好像自問自答\n目的   以廣播的形式告訴大家自己的IP與MAC，不期望得到回應\n  藉由此方法發現發現有沒有其他人使用此IP，如果有人回應則代表IP衝突\n  也順便藉由此方式更新自己的MAC給其他設備，預防自己換網卡(MAC)\n  GARP 請求 與 回應 發送免費ARP，我要使用XX地址，請問有人使用嗎?使用的人請你告訴我。\n 來源IP 與 目標IP 地址相同 目標MAC是廣播MAC  如果有人回應，我正在使用地址XXX，就代表發生IP衝突\n 來源IP 與 目標IP 地址相同 目標MAC為廣播MAC  資料來源 免費ARP與IP位址衝突\n","permalink":"https://patrick85081.github.io/posts/2021-05-19-arp-protocol/","tags":["ARP","Network"],"title":"ARP 協議"},{"categories":null,"contents":"Halcon是一套付費的影像處裡函式庫，為了方便測試裡面的影像處理功能，所以她有整合了一些相機取像的功能，Halcon將軟體切成四層：\n軟體架構   Halcon Application\n這裡代表我們開發的軟體，或者HDevlop測試工具\n  Halcon Image Processing Library\n這裡是我們使用的Halcon函示庫，就是halcon.dll\n  Halcon xyz Frame Grabber Interface\nHalcon做的一套中間取像的抽象層，也就是我們軟體界所說的 interface\n  Frame Grabber Driver \u0026amp; SDK\n這裡是實作取像功能的實作，整合不同廠牌的相機驅動，為了方便我們可以使用\n  使用方式  選擇實作介面 也可以使用自動偵測，判斷電腦本身可以使用哪些取像實作   連結相機 這裡展示就只使用File方式，指定資料夾內的影像，模擬相機取像的效果。   相機參數設定 這裡可以設定相機參數，例如使用GenICamTL，這裡就會出現GenICamTL參數   使用範本產生程式碼  HDevelop Demo C# Demo 對於寫相機SDK有經驗的朋友可能會說，相機SDK怎麼可以沒有取像Callback方法呢?\n其實Halcon也有提供，但經過測試發現不是所有的實作都支援Callback方法，但如果只是要取像測試的話，這樣單張取像的方式應該也就夠用了。\nHalcon Frame Grabber Callback 測試過 GenICamTL 有支援\nvar grabber = new HFramegrabber( \u0026#34;GenICamTL\u0026#34;, 0, 0, 0, 0, 0, 0, \u0026#34;progressive\u0026#34;, -1, \u0026#34;default\u0026#34;, -1, \u0026#34;false\u0026#34;, \u0026#34;default\u0026#34;, _deviceName, 0, -1); grabber.SetFramegrabberParam(\u0026#34;TriggerMode\u0026#34;, \u0026#34;Off\u0026#34;); // 建立 相機 Callback var callback = Marshal.GetFunctionPointerForDelegate( new HalconAPI.HFramegrabberCallback(HalconGrab_Callback)); grabber.SetFramegrabberCallback(\u0026#34;LineStatus\u0026#34;, callback, IntPtr.Zero); grabber.GrabImageStart(-1); private int HalconGrab_Callback(IntPtr handle, IntPtr userContext, IntPtr context) { try { if (ImageGrabbed == null) return 0; // Get Frame Grabber Image  var hImage = grabber.GrabImage(); return 0; } catch (Exception ex) { // MessageBox.Show(ex.Message);//显示错误  return -1; } } ","permalink":"https://patrick85081.github.io/posts/2021-02-03-halcon-frame-grabber/","tags":["Halcon","Grabber"],"title":"Halcon Frame Grabber"},{"categories":null,"contents":"當要跟PLC做資料交換溝通時，常常會碰到一個問題，PLC是16bit的系統，傳遞字串與數字時都需要經過一些處理，高位元與低位元的byte處理，這裡做個紀錄以免忘記。\n字串類型 PLC一個Device為16bit，一個字元為8bit，所以可放兩個字元。\n寫入字串 我們需要將一串文字兩個字元一組轉成int，寫入int陣列進去PLC。 程式的邏輯應該長這樣\n 一個int = 高位元文字(char[1]) * 256 + 低位元文字(char[0])\n 來，我們來看程式碼：\n// 輸入的字串 string text = \u0026#34;Patrick\u0026#34;; int[] datas = ( // 總共有幾組  from num in Enumerable.Range(0, (text.Length + 1)) // 每一組的起始 index  let startIndex = num * 2 // 低位元  let low = text.ElementAtOrDefault(startIndex) // 高位元  let heigh = text.ElementAtOrDefault(startIndex + 1) select height * 256 + low ) .ToArray(); 讀入字串 接下來我們需要將int 陣列轉回字串，一個int為兩個字元，程式的虛擬碼長這樣：\n char[0] = 低位元 (char)(int % 256)\nchar[1] = 高位元 (char)(int / 256)\n 來，我們來看程式碼\nint[] datas; char[] charArray = ( from num in datas let chars new char[] { // 低位元  (char) (num % 256), // 高位元  (char) (num / 256), } from c in chars select c ) .ToArray(); // 轉換回字串，過濾開頭結尾的 \u0026#39;\\0\u0026#39; 的字元 var text = new string(charAray).Trim(\u0026#39;\\0\u0026#39;); 32bit 數字 c#中的int全名就叫做int32剛好就是32bit，前面說過PLC一個Device只有16bit，所以要把兩個Device轉成int32\n寫入32bit數字 我們需要拆解int32成4個bytes，兩個bytes一組轉成int16，最後再轉成int32\n 輸入數字 (int) =\u0026gt; byte[4]\n結果\nint[0] = byte[0] byte[1]\nint[1] = byte[2] byte[3]\n int value = -200; var bytes = BitConverter.GetBytes(value); var datas = ( from num in Enumerable.Range(0, 1) let index = num * 2 let int16 = BitConverter.ToInt16(bytes, index) let int32 = Convert.ToInt32(int16) select int32 ) .ToArray() 讀取32bit數字 我們從PLC讀出兩個DeviceBlock，得到長度為2的int陣列，我們需要各從這兩個int身上讀取兩個byte組合成一個int\nint[] datas; byte[] byteArray = ( from data in datas from @byte in BitConverter.GetBytes(data) .Take(2) select @byte ) .ToArray(); int result = BitConverter.ToInt32(byteArray, 0); 16bit數字 寫入沒有太大的問題，主要是讀取資料時候，數字又是負數，產生的問題\n PLC Device : FF F0\n到達C# int32 : 00 00 FF F0\n 這個時候數字解讀就會有問題\n讀取16bit數字 int num = -200; byte[] bytes = BitConverter.GetBytes(num).Take(2).ToArray(); short int16 = BitConverter.ToInt16(bytes, 0); ","permalink":"https://patrick85081.github.io/posts/2020-11-21-plc-data-read-write/","tags":["PLC"],"title":"PLC 讀寫資料轉換"},{"categories":null,"contents":"開發 WinForm 時，要做到WinForm內部對話框，而且又可以按住標題拖曳的效果，可以透過Panel手刻出對話框，透過WinAPI做到拖曳效果。\npublic partial class Form1 : Form { [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool ReleaseCapture(); [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam); public Form1() { InitializeComponent(); } private void DialogTitle_MouseDown(object sender, MouseEventArgs e) { if (e.Button == MouseButtons.Left) { //釋放鼠標捕捉  ReleaseCapture(); //發送左鍵點擊的消息至該視窗  SendMessage(FrocePanel1.Handle, 0xA1, 0x02, 0); } } } 範例程式碼\n","permalink":"https://patrick85081.github.io/posts/2020-11-20-winform-drag-inner-dialog-panel/","tags":["WinForm","WinAPI"],"title":"WinForm 內部對話框，標題拖曳功能"},{"categories":null,"contents":"影像分割 固定二值化 // P3, P4 =\u0026gt; 二值化閥值區間 threshold(GrayImage, DarkArea, 0, 128) 直方圖自動二值化 // P3 =\u0026gt; Sigma 高斯運算 平滑算子 auto_threshold(GrayImage, DarkArea, 8.0)  P.S. 可用 gray_histo or gen_region_histo 查看直方圖\n 自動全局二值化  利用直方圖像素分佈，例如最大類間方插法或平滑直方圖法\n // P3 =\u0026gt; 二值化的方法 // max_separability 直方圖中最大的可分性分割 // smooth_histo 平滑直方圖 // P4 =\u0026gt; 取 亮部 light 還是 暗部 dark // P5 =\u0026gt; 輸出 自動二值化使用的閥值 binary_threshold(GrayImage, DarkArea, \u0026#39;max_separability\u0026#39;, \u0026#39;dark\u0026#39;, UsedThreshold) 局部閥值分割法  適用於無法用單一灰階分割情況，如背景複雜，亮暗不均\n 步驟\n 套用平滑濾波器 使用dyn_threshold 比較 原始圖像 與 套用平滑濾波器 後的影像差異，將差異大於設定值的點找出來  // P3 =\u0026gt; 輸出的閥值區域 // P4 =\u0026gt; Offset 值，比較後大於該值將被提取出來 // P5 =\u0026gt; 哪個區域 // light 原圖 \u0026gt;= 平滑後 + Offset // dark 原圖 \u0026lt;= 平滑後 - Offset // equal (平滑後 + Offset) \u0026lt; 原圖 \u0026lt; (平滑後 - Offset) // not_equal (平滑後 + Offset) \u0026gt;= 原圖 Or 原圖 \u0026gt;= (平滑後 - Offset) dyn_threshold(Image, ImageMean, RegionDynThresh, 4, \u0026#39;not_equal\u0026#39;) Var_Threshold // P3, P4 =\u0026gt; Mask 長寬 // P5 =\u0026gt; 標準差因子 // P6 =\u0026gt; 絕對閥值 // P7 =\u0026gt; dark, light, equal, not_equal var_threshold(Image, Region, 15, 15, 0.2, 35, \u0026#39;darkk\u0026#39;) Char_Threshold char_threshold(Imge, Image, Characters, 6, 95, Threshold) Dual_Threshold dual_threshold(Imge, RegionCrossings, MinSize, MinGray, Threshold) 區域生長法 RegiongRowing  將灰階相近的像素合併\n // P3, P4 =\u0026gt; 矩形區域長寬 (奇數) // P5 =\u0026gt; 灰階差的分割標準 // P6 =\u0026gt; 輸出區域的最小像素 regiongrowing(Image, Regions, 1, 1, 3.0, 100)  Bayer RG8 to Halcon Halcon CfaToRgb  將單通道彩色，轉換成三通道\n // cfa_to_rgb — Convert a single-channel color filter array image into an RGB image. // CFAType: \u0026#39;bayer_bg\u0026#39;, \u0026#39;bayer_gb\u0026#39;, \u0026#39;bayer_gr\u0026#39;, \u0026#39;bayer_rg\u0026#39; // Interpolation: \u0026#39;bilinear\u0026#39;, \u0026#39;bilinear_dir\u0026#39;, \u0026#39;bilinear_enhanced\u0026#39; static void HOperatorSet.CfaToRgb(HObject CFAImage, out HObject RGBImage, HTuple CFAType, HTuple interpolation) Basler Grab result to Halcon\n图像Bayer格式介绍以及Bayer插值原理CFA\n图像bayer格式介绍以及bayer插值原理\n","permalink":"https://patrick85081.github.io/posts/2020-11-18-halcon-note/halcon-note/","tags":["Halcon"],"title":"Halcon 常用的Function"},{"categories":null,"contents":"這裡來記錄一下PLC模擬器的設定方式，以及C#連接PLC的程式碼。\nCommunication 設定教學 模擬器連線設定  設定 Station Number  PLC類型 選擇模擬器 GX Simulator2  設定連線名稱  完成結果  透過網路連線設定  選擇 網路以及連線模式  設定IP  設定模式 以及 CPU類型   連線名稱   完成結果  GX Work2 啟動模擬器  開啟新專案  開始 模擬  C# 開發方式  加入參考 MITSUBISHI ActMulti Control  參考清單  Coding  var easyIf = new ActEasyIF(); easyIf.ActLogicalStationNumber = 1; if (easyIf.Open() != 0) throw new Exception(\u0026#34;連線失敗\u0026#34;); // Read Block (D0 ~ D49) var buffer = new int[50]; easyIf.ReadDeviceBlock(\u0026#34;D0\u0026#34;, buffer.Length, out buffer[0]); // Write Block (D0 ~ D49) easyIf.WriteDeviceBlock(\u0026#34;D0\u0026#34;, buffer.Length, ref buffer[0]); // Read Device int value = 123; easyIf.GetDevice(\u0026#34;D0\u0026#34;, out value); // Write Device easyIf.SetDevice(\u0026#34;D0\u0026#34;, value); ","permalink":"https://patrick85081.github.io/posts/2020-11-08-plc-emulator-communication/","tags":["PLC"],"title":"PLC 連線設定"},{"categories":null,"contents":"這裡來介紹一下三菱MT-2200 馬達脈波控制器使用方式。\n市面上的馬達驅動器分為兩種，一種是脈波(Plus)與資料通訊的訊號傳 遞方式，脈波型是屬於通用型，不同廠牌的控制器、馬達驅動器與馬達只要送相對應的脈波都可以互相控制，但是資料通訊就不一樣了，各家都有各家的通訊方式無法互通，換句話說全部都只能使用同一家的設備，資料通訊的好處是時脈可以比脈波通訊快很多，而且佈線走線都很簡單而且訊號品質也會比脈波好，三菱走的是SSCNET III/H光纖通訊。\n當需要同時控制脈波型與通訊型的馬達時，正常的情況只能分別接兩種運動控制卡分別控制，MT-2000系列目的就是讓脈波型的馬達驅動器經過通訊卡(MT-2010)，也可以走SSCNET III/H通訊，優點是可以減少一張脈波型運動控制卡成本。\n  MT-2010 為通訊卡\n可以將MT-2000系列的裝置使用SSCNET III/H通訊\n  MT-2100 為數位IO卡\n  MT-2200 為脈波控制卡\n可以透過此卡操控脈波型的馬達\n  MT-2300 為類比IO卡\n  MT-2400 為Encoder 輸入卡\n  安裝 使用工業卡扣的設計\n區塊 一張MT-2010通訊卡最多只能接四個模組(設備)，通訊卡加上底下的設備稱為一個區塊(Block)。\nMT-2200 脈波控制卡 脈波控制卡的最大特色是，他擁有兩組脈波IO訊號，可以分別選擇脈波要當 輸入還是輸出功能。\n設定 軸號/站號 在MT-2200上頭有兩個旋轉開關，由此設定 SSCNET III/H的設備編號\n模式設定 MT-2200有兩種模式，一種稱為站模式(Station Mode)和軸模式(Axis Mode)\n  站模式\n此模式就像把MT-2200當成脈波控制的IO卡，自行控制脈波的輸出。\n  軸模式 (推薦)\n此模式就像把MT-2200當成運動控制卡來做控制，軟體面來說就跟操控一般馬達沒有兩樣。\n前面有說到 脈波控制卡有兩組脈波IO，可以分別選擇要做 輸入還是輸出使用，對應馬達控制的話就是要 輸出馬達訊號 還是 Encoder回授訊號接收，換句話說要讓 MT-2200 輸出脈波給兩個馬達，還是 輸出脈波給一個馬達並接收一個Encoder訊號。\n  接線方式 把 MT-2010通訊卡當作一般的三菱驅動器接線即可。\n 這裡特別要記住，前面說過一個MT-2010可以接四個設備，如果一個MT-2200輸出訊號給兩個馬達，這樣一個MT-2200就算兩個設備。\n 站模式 (Station Mode) 站模式下可以分別控制每一個IO訊號。\n驅動器設定 驅動器型號  0x3015 – 通訊模組Block上的第一軸\n0x3025 – 通訊模組Block上的其他軸\n 輸出脈波設定 單脈波控制、雙脈波控制、AB相控制 信號正反邏輯設定\nEncoder 輸入設定 單脈波控制、雙脈波控制、AB相控制 信號正反邏輯設定 ","permalink":"https://patrick85081.github.io/posts/2020-11-03-mr-mt-2200/","tags":["PLC","Motion"],"title":"三菱 MR-MT-2200 馬達脈波控制器"},{"categories":null,"contents":"問題情境 假設因相機或機構問題，相機取到的影像需做簡易影像旋轉和翻轉功能。我們來做幾個簡單的實驗，驗證影像記憶體的佔用情況。\n需求：\n 彩色黑白轉換 水平翻轉 垂直翻轉 旋轉  跑一千次觀察記憶體使用量 方案一 HImage依序做完所有的影像處理。 方案二 HImage 每做完一個影像處裡，就Dispose前一張影像` 結論 Halcon 每做完一次影像處理，其實是做資料複製，記憶體中的資料從一張影像會變成兩張影像，做越多次處裡記憶體的佔用也就越大，所以記得每次處理完都需要做影像銷毀。\n附上範例程式碼，執行前請先安裝Halcon 12\n","permalink":"https://patrick85081.github.io/posts/2020-10-06-halcon-image-leak/","tags":["Halcon"],"title":"Halcon 影像記憶體洩漏"},{"categories":null,"contents":"","permalink":"https://patrick85081.github.io/search/","tags":null,"title":"Search Results"}]