<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PLC on 派翠克技術手札</title><link>https://patrick85081.github.io/tags/plc/</link><description>Recent content in PLC on 派翠克技術手札</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sat, 21 Nov 2020 20:04:23 +0800</lastBuildDate><atom:link href="https://patrick85081.github.io/tags/plc/index.xml" rel="self" type="application/rss+xml"/><item><title>PLC 讀寫資料轉換</title><link>https://patrick85081.github.io/posts/2020-11-21-plc-data-read-write/</link><pubDate>Sat, 21 Nov 2020 20:04:23 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-21-plc-data-read-write/</guid><description>當要跟PLC做資料交換溝通時，常常會碰到一個問題，PLC是16bit的系統，傳遞字串與數字時都需要經過一些處理，高位元與低位元的byte處理，這裡做個紀錄以免忘記。
字串類型 PLC一個Device為16bit，一個字元為8bit，所以可放兩個字元。
寫入字串 我們需要將一串文字兩個字元一組轉成int，寫入int陣列進去PLC。 程式的邏輯應該長這樣
一個int = 高位元文字(char[1]) * 256 + 低位元文字(char[0])
來，我們來看程式碼：
// 輸入的字串 string text = &amp;#34;Patrick&amp;#34;; int[] datas = ( // 總共有幾組 from num in Enumerable.Range(0, (text.Length + 1)) // 每一組的起始 index let startIndex = num * 2 // 低位元 let low = text.ElementAtOrDefault(startIndex) // 高位元 let heigh = text.ElementAtOrDefault(startIndex + 1) select height * 256 + low ) .ToArray(); 讀入字串 接下來我們需要將int 陣列轉回字串，一個int為兩個字元，程式的虛擬碼長這樣：</description></item><item><title>PLC 連線設定</title><link>https://patrick85081.github.io/posts/2020-11-08-plc-emulator-communication/</link><pubDate>Sun, 08 Nov 2020 22:37:59 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-08-plc-emulator-communication/</guid><description>這裡來記錄一下PLC模擬器的設定方式，以及C#連接PLC的程式碼。
Communication 設定教學 模擬器連線設定 設定 Station Number PLC類型 選擇模擬器 GX Simulator2 設定連線名稱 完成結果 透過網路連線設定 選擇 網路以及連線模式 設定IP 設定模式 以及 CPU類型 連線名稱 完成結果 GX Work2 啟動模擬器 開啟新專案 開始 模擬 C# 開發方式 加入參考 MITSUBISHI ActMulti Control 參考清單 Coding var easyIf = new ActEasyIF(); easyIf.ActLogicalStationNumber = 1; if (easyIf.Open() != 0) throw new Exception(&amp;#34;連線失敗&amp;#34;); // Read Block (D0 ~ D49) var buffer = new int[50]; easyIf.</description></item><item><title>三菱 MR-MT-2200 馬達脈波控制器</title><link>https://patrick85081.github.io/posts/2020-11-03-mr-mt-2200/</link><pubDate>Tue, 03 Nov 2020 20:40:52 +0800</pubDate><guid>https://patrick85081.github.io/posts/2020-11-03-mr-mt-2200/</guid><description>這裡來介紹一下三菱MT-2200 馬達脈波控制器使用方式。
市面上的馬達驅動器分為兩種，一種是脈波(Plus)與資料通訊的訊號傳 遞方式，脈波型是屬於通用型，不同廠牌的控制器、馬達驅動器與馬達只要送相對應的脈波都可以互相控制，但是資料通訊就不一樣了，各家都有各家的通訊方式無法互通，換句話說全部都只能使用同一家的設備，資料通訊的好處是時脈可以比脈波通訊快很多，而且佈線走線都很簡單而且訊號品質也會比脈波好，三菱走的是SSCNET III/H光纖通訊。
當需要同時控制脈波型與通訊型的馬達時，正常的情況只能分別接兩種運動控制卡分別控制，MT-2000系列目的就是讓脈波型的馬達驅動器經過通訊卡(MT-2010)，也可以走SSCNET III/H通訊，優點是可以減少一張脈波型運動控制卡成本。
MT-2010 為通訊卡
可以將MT-2000系列的裝置使用SSCNET III/H通訊
MT-2100 為數位IO卡
MT-2200 為脈波控制卡
可以透過此卡操控脈波型的馬達
MT-2300 為類比IO卡
MT-2400 為Encoder 輸入卡
安裝 使用工業卡扣的設計
區塊 一張MT-2010通訊卡最多只能接四個模組(設備)，通訊卡加上底下的設備稱為一個區塊(Block)。
MT-2200 脈波控制卡 脈波控制卡的最大特色是，他擁有兩組脈波IO訊號，可以分別選擇脈波要當 輸入還是輸出功能。
設定 軸號/站號 在MT-2200上頭有兩個旋轉開關，由此設定 SSCNET III/H的設備編號
模式設定 MT-2200有兩種模式，一種稱為站模式(Station Mode)和軸模式(Axis Mode)
站模式
此模式就像把MT-2200當成脈波控制的IO卡，自行控制脈波的輸出。
軸模式 (推薦)
此模式就像把MT-2200當成運動控制卡來做控制，軟體面來說就跟操控一般馬達沒有兩樣。
前面有說到 脈波控制卡有兩組脈波IO，可以分別選擇要做 輸入還是輸出使用，對應馬達控制的話就是要 輸出馬達訊號 還是 Encoder回授訊號接收，換句話說要讓 MT-2200 輸出脈波給兩個馬達，還是 輸出脈波給一個馬達並接收一個Encoder訊號。
接線方式 把 MT-2010通訊卡當作一般的三菱驅動器接線即可。</description></item></channel></rss>