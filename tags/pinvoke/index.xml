<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PInvoke on 派翠克技術手札</title><link>https://patrick85081.github.io/tags/pinvoke/</link><description>Recent content in PInvoke on 派翠克技術手札</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Sat, 09 Apr 2022 11:04:49 +0800</lastBuildDate><atom:link href="https://patrick85081.github.io/tags/pinvoke/index.xml" rel="self" type="application/rss+xml"/><item><title>C# 呼叫 C/C++ 函式庫</title><link>https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/</link><pubDate>Sat, 09 Apr 2022 11:04:49 +0800</pubDate><guid>https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/</guid><description>很多場景都需要與C/C++ Library溝通做朋友，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。
靜態呼叫 使用C#的DllImport去匯入C語言function，例如在user32.dll中的MessageBox，這時候要先了解裡面的資料型態該如何去對應C#資料型態。
MessageBox在user32.dll宣告長這樣: MessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); 使用C# 呼叫 using System; using System.Runtime.InteropServices; [DllImport(&amp;#34;user32.dll&amp;#34;)] private static extern int MessageBox(IntPtr hWnd, String text, String caption, int type); public static void Main() { MessageBox(IntPtr.Zero, &amp;#34;Text&amp;#34;, &amp;#34;Caption&amp;#34;, 0); } C struct 的對應 還有一種情況，C function中使用的類型不是基本型別，是額外定義的型別，我們也需要定義對應的C# 物件來接收，就拿 Kernal32.dll中的 GetSystemTime來說
void GetSystemTime(LPSYSTEMTIME lpSystemTime); typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds; } SYSTEMTIME, *PSYSTEMTIME; 要呼叫這個function，我們必須定義一個C#的Class和C Struct有一樣的結構，而且成員的順序也需要相同。</description></item></channel></rss>