<!doctype html><html lang=zh-tw><head><title>C# 呼叫 C/C++ 函式庫 // 派翠克技術手札</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Patrick"><meta name=description content="這些年累積下來的經驗，很多場景都需要與C/C++ Library溝通，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。"><link rel=stylesheet href=https://patrick85081.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><meta name=twitter:card content="summary"><meta name=twitter:title content="C# 呼叫 C/C++ 函式庫"><meta name=twitter:description content="這些年累積下來的經驗，很多場景都需要與C/C++ Library溝通，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。"><meta property="og:title" content="C# 呼叫 C/C++ 函式庫"><meta property="og:description" content="這些年累積下來的經驗，很多場景都需要與C/C++ Library溝通，當 C# 需要呼叫 C/C++ 程式庫時，需要使用PInvoke(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地Win32API，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。"><meta property="og:type" content="article"><meta property="og:url" content="https://patrick85081.github.io/posts/2022-04-09-csharp-pinvoke-c-library/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-09T11:04:49+08:00"><meta property="article:modified_time" content="2022-04-09T11:04:49+08:00"></head><body><header class=app-header><a href=https://patrick85081.github.io/><img class=app-header-avatar src=/avatar.png alt=Patrick></a><h1>派翠克技術手札</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>首頁</a>
-
<a class=app-header-menu-item href=/tags/>標籤</a>
-
<a class=app-header-menu-item href=/search/>文章搜尋</a></nav><p>這裡是派翠克技術手札</p><div class=app-header-social><a href=https://github.com/patrick85081 target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=/index.xml target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-rss"><title>Rss</title><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a><a href=mailto:patrick85081@gmail.com target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail"><title>聯絡我</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>C# 呼叫 C/C++ 函式庫</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2022-04-09, Saturday</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://patrick85081.github.io/tags/pinvoke/>PInvoke</a>
<a class=tag href=https://patrick85081.github.io/tags/windowsapi/>WindowsAPI</a></div></div></header><div class=post-content><p>這些年累積下來的經驗，很多場景都需要與<code>C/C++ Library</code>溝通，當 C# 需要呼叫 C/C++ 程式庫時，需要使用<code>PInvoke</code>(Platform Invocation Services)，來呼叫裡面的function，常用到的場景是呼叫Windows原生地<code>Win32API</code>，或是使用硬體SDK時只提供C 函式庫，這裡也有好幾種狀況與方式，紀錄一下方便可以快速了解。</p><h1 id=靜態呼叫>靜態呼叫</h1><p>使用C#的<code>DllImport</code>去匯入C語言function，例如在<code>user32.dll</code>中的<code>MessageBox</code>，這時候要先了解裡面的資料型態該如何去對應C#資料型態。</p><ul><li><code>MessageBox</code>在<code>user32.dll</code>宣告長這樣:</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>MessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);  
</code></pre></div><ul><li>使用C# 呼叫</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Runtime.InteropServices;
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[DllImport(&#34;user32.dll&#34;)]</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> MessageBox(IntPtr hWnd, String text, String caption, <span style=color:#66d9ef>int</span> type);

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
{
    MessageBox(IntPtr.Zero, <span style=color:#e6db74>&#34;Text&#34;</span>, <span style=color:#e6db74>&#34;Caption&#34;</span>, <span style=color:#ae81ff>0</span>);
}
</code></pre></div><h2 id=c-struct-的對應>C struct 的對應</h2><p>還有一種情況，C function中使用的類型不是基本型別，是額外定義的型別，我們也需要定義對應的C# 物件來接收，就拿 <code>Kernal32.dll</code>中的 <code>GetSystemTime</code>來說</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>GetSystemTime</span>(LPSYSTEMTIME lpSystemTime);

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _SYSTEMTIME {
  WORD wYear;
  WORD wMonth;
  WORD wDayOfWeek;
  WORD wDay;
  WORD wHour;
  WORD wMinute;
  WORD wSecond;
  WORD wMilliseconds;
} SYSTEMTIME, <span style=color:#f92672>*</span>PSYSTEMTIME;
</code></pre></div><p>要呼叫這個function，我們必須定義一個C#的Class和C Struct有一樣的結構，而且成員的順序也需要相同。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=color:#66d9ef>using</span> System;
<span style=color:#66d9ef>using</span> System.Runtime.InteropServices;     
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[StructLayout(LayoutKind.Sequential)]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SystemTime</span> 
{
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> year;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> month;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> weekday;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> day;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> hour;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> minute;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> second;
   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>ushort</span> millisecond;
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=color:#a6e22e>[DllImport(&#34;Kernel32.dll&#34;)]</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> GetSystemTime(SystemTime st);

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
{
    SystemTime t = <span style=color:#66d9ef>new</span> SystemTime();
    GetSystemTime(t);
    Console.WriteLine(t.Year);
}
</code></pre></div><p>這裡有一個網站可以查詢常用的 Windows API 怎麼對應 C#的寫法。<br><a href=http://www.pinvoke.net/>PInvoke.Net</a></p><hr><h1 id=動態呼叫>動態呼叫</h1><p>還有一種作法可以執行的時候才動態去連結指定的function，這種作法寫起來較為麻煩，但是適合的場景為硬體SDK同時提供 <code>x86</code>和 <code>x64</code>的 C API，那我們要包裝成C#時可以動態根據程式架構去連結/調用相對應的API，將讀進來的C function用相對應的<code>C# delegate(function point)</code>來接收，使用時只要呼叫delegate就可以。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=color:#a6e22e>[DllImport(&#34;kernel32&#34;, CharSet = CharSet.Unicode, SetLastError = true)]</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> IntPtr LoadLibrary(<span style=color:#66d9ef>string</span> lpFileName);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[DllImport(&#34;kernel32&#34;, SetLastError = true)]</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>bool</span> FreeLibrary(IntPtr hModule);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>[DllImport(&#34;kernel32&#34;, CharSet = CharSet.Ansi, SetLastError = true, ExactSpelling = false)]</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> IntPtr GetProcAddress(IntPtr hModule, <span style=color:#66d9ef>string</span> lpProcName);

<span style=color:#75715e>// 定義對應的 C Function 的 函式指標
</span><span style=color:#75715e></span><span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> DelegateGetSystemTime(SystemTime st);

<span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span> args[])
{
    <span style=color:#75715e>// 讀取 C dll
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> lib = LoadLibrary(<span style=color:#e6db74>&#34;Kernel32.dll&#34;</span>);

    <span style=color:#75715e>// load function to c# function point (delegate)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> getSystemTime = (DelegateGetSystemTime) 
        Marshal.GetDelegateForFunctionPointer(
            GetProcAddress(lib, <span style=color:#e6db74>&#34;GetSystemTime&#34;</span>), 
            <span style=color:#66d9ef>typeof</span>(DelegateGetSystemTime));

    <span style=color:#75715e>// 調用
</span><span style=color:#75715e></span>    SystemTime tt = <span style=color:#66d9ef>new</span> SystemTime();
    getSystemTime(tt);

    <span style=color:#75715e>// 釋放 C dll
</span><span style=color:#75715e></span>    FreeLibrary(lib);
}
</code></pre></div><hr><h1 id=查詢-c-function的-entrypoint>查詢 C function的 EntryPoint</h1><p>通常 C function的方法名稱就是<code>EntryPoint</code>，所以<code>DllImport</code>沒有指定<code>EntryPoint</code>時就會使用方法名稱作為<code>EntryPoint</code>，但是筆者這裡也有碰過硬體廠商提供的C API沒有遵守這個規則，去做對應時候要額外指定<code>EntryPoint</code>，偏偏說明書又沒有告訴你它的<code>EntryPoint</code>，筆者沒有寫過C語言，裡面的原因沒有深入去了解，不過有一套工具可以去查詢C function對應的EntryPoint，它叫做<a href=https://github.com/lucasg/Dependencies>Dependencies</a>。</p><p>利用<code>Dendencies</code>開啓C dll後，可以看到這個dll相依其他的dll，還有他的function清單，就像前面說的一般的function都會跟EntryPoint相同。
<img src=Dependencies_1.png alt></p><p>這時候按下右鍵，<code>Undecoderate C++ Function</code>取消。
<img src=Dependencies_2.png alt></p><p>所有的function就原形畢露了，EntryPoint是 <strong>?</strong> 開頭，<strong>@@YAHPAXPAE@Z</strong> 結尾。
<img src=Dependencies_3.png alt></p><p>這個時候就能成功的對應function了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=color:#a6e22e>[DllImport(&#34;****.dll&#34;, EntryPoint = &#34;?****_12GPIO_SetValue@@YAHPAXDE@Z&#34;, SetLastError = true, CharSet = CharSet.Unicode)]</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> ****_12GPIO_SetValue(IntPtr hdrv, <span style=color:#66d9ef>int</span> GPIO_Num, <span style=color:#66d9ef>bool</span> val);
</code></pre></div><hr><h1 id=實際寫一個-c-library-來讓-c-呼叫>實際寫一個 C++ Library 來讓 C# 呼叫</h1><p>讓我們實際寫一個 C++ Library來讓 C# 呼叫，這樣就能了解到雙方的溝通原理。</p><ul><li><p>新增 C++ Win32專案
<img src=C_Project_For_CSharp_1.png alt></p></li><li><p>選擇程式類型
<img src=C_Project_For_CSharp_2.png alt></p></li><li><p>設定專案 CLR 支援
<img src=C_Project_For_CSharp_3.png alt></p></li><li><p>實際寫一個 C++ Library<br>宣告C++物件 <code>Calculate</code></p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// Calculate.h
</span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span><span style=color:#75715e></span>class Calculate
{
public:
    Calculate();

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Addition</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);<span style=color:#75715e>//加法
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Subtraction</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);<span style=color:#75715e>//剪髮
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>RegisterCallback</span>(<span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>callback)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>));<span style=color:#75715e>// 註冊函式指標，作為Callback Function
</span><span style=color:#75715e></span>};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// Calculate.cpp
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Calculate.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
Calculate<span style=color:#f92672>::</span>Calculate()
{
}

<span style=color:#66d9ef>int</span> Calculate<span style=color:#f92672>::</span>Addition(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
}

<span style=color:#66d9ef>int</span> Calculate<span style=color:#f92672>::</span>Subtraction(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>-</span> b;
}

<span style=color:#66d9ef>void</span> Calculate<span style=color:#f92672>::</span>RegisterCallback(<span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>callback)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>))
{
    <span style=color:#75715e>// 呼叫 callback 方法
</span><span style=color:#75715e></span>    callback(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>);
}
</code></pre></div><ul><li>建立 C 函式 風格的包裝<br>由於 C# PInvoke無法直接使用C++物件，所以需要包裝成<code>C語言風格</code>的方式，<strong>創建物件</strong>、<strong>銷毀物件</strong>、<strong>其他方法</strong>、<strong>註冊Callback</strong>等等需要另外包裝。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// ForExternCall.cpp
</span><span style=color:#75715e></span><span style=color:#75715e>#ifdef TESTDLL_EXPORTS </span><span style=color:#75715e>//同專案名稱，只是後面固定為_EXPORTS
</span><span style=color:#75715e></span><span style=color:#75715e>#define TestDll_API __declspec(dllexport) </span><span style=color:#75715e>//請注意！正確的是Export要亮起
</span><span style=color:#75715e></span><span style=color:#75715e>#else
</span><span style=color:#75715e>#define TestDll_API __declspec(dllimport)
</span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
<span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Calculate.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> TestDll_API Calculate<span style=color:#f92672>*</span> CreateInstance()
{
    <span style=color:#66d9ef>return</span> new Calculate();
}

<span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> TestDll_API <span style=color:#66d9ef>void</span> DisposeInstance(Calculate<span style=color:#f92672>*</span> instance)
{
    <span style=color:#66d9ef>if</span> (instance <span style=color:#f92672>!=</span> nullptr)
    {
        delete instance;
        instance <span style=color:#f92672>=</span> nullptr;
    }
}

<span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> TestDll_API <span style=color:#66d9ef>int</span> Add(Calculate<span style=color:#f92672>*</span> instance, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{    
    <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>-&gt;</span>Addition(a, b);
}

<span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> TestDll_API <span style=color:#66d9ef>int</span> Sub(Calculate<span style=color:#f92672>*</span> instance, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
{
    <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>-&gt;</span>Subtraction(a, b);
}

<span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> TestDll_API <span style=color:#66d9ef>void</span> RegisterCallback(Calculate<span style=color:#f92672>*</span> instance, <span style=color:#66d9ef>void</span>(<span style=color:#f92672>*</span>callback)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>))
{
    <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>-&gt;</span>RegisterCallback(callback);
}
</code></pre></div><ul><li>最後做完的專案結構會類似這樣</li></ul><p><img src=C_Project_For_CSharp_4.png alt></p><ul><li>實際C#物件包裝使用<br>由於原本物件導向的方式被拆成，函數式的形式，所以最後需要利用C#包裝回物件導向的形式。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Calculate</span> : IDisposable
{
    <span style=color:#75715e>//傳入和傳出的型態格式必須同ForExternCall.cpp內的設置！！
</span><span style=color:#75715e></span>
    <span style=color:#75715e>//也可以不設置進入點，但函數名稱必須相同
</span><span style=color:#75715e></span><span style=color:#a6e22e>    [DllImport(&#34;TestDll.dll&#34;, EntryPoint = &#34;CreateInstance&#34;)]</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> IntPtr CreateInstance();
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [DllImport(&#34;TestDll.dll&#34;, EntryPoint = &#34;DisposeInstance&#34;)]</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> DisposeInstance(IntPtr instance);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [DllImport(&#34;TestDll.dll&#34;, EntryPoint = &#34;Add&#34;)]</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> Add(IntPtr instance, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [DllImport(&#34;TestDll.dll&#34;, EntryPoint =&#34;Sub&#34;)]</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> Sub(IntPtr instance, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b);
<span style=color:#a6e22e>
</span><span style=color:#a6e22e>    [DllImport(&#34;TestDll.dll&#34;, EntryPoint = &#34;RegisterCallback&#34;)]</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>void</span> RegisterCallback(IntPtr instance, Callback callback);

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> Callback(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d);

    IntPtr instance = IntPtr.Zero;

    <span style=color:#66d9ef>public</span> Calculate()
    {
        instance = CreateInstance();
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Add(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
    {
        <span style=color:#66d9ef>return</span> Add(instance, a, b);
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Sub(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b)
    {
        <span style=color:#66d9ef>return</span> Sub(instance, a, b);
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RegisterCallback(Callback callback)
    {
        RegisterCallback(instance, callback);
    }

    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Dispose(<span style=color:#66d9ef>bool</span> bDisposing)
    {
        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.instance != IntPtr.Zero)
        {
            <span style=color:#75715e>// Call the DLL Export to dispose this class
</span><span style=color:#75715e></span>            DisposeInstance(<span style=color:#66d9ef>this</span>.instance);
            <span style=color:#66d9ef>this</span>.instance = IntPtr.Zero;
        }

        <span style=color:#66d9ef>if</span> (bDisposing)
        {
            <span style=color:#75715e>// No need to call the finalizer since we&#39;ve now cleaned
</span><span style=color:#75715e></span>            <span style=color:#75715e>// up the unmanaged memory
</span><span style=color:#75715e></span>            GC.SuppressFinalize(<span style=color:#66d9ef>this</span>);
        }
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
    {
        Dispose(<span style=color:#66d9ef>true</span>);
    }

    ~Calculate()
    {
        Dispose(<span style=color:#66d9ef>false</span>);
    }
}
</code></pre></div><h2 id=範例程式>範例程式</h2><p><a href=https://github.com/patrick85081/CSharpCallCPluseDll>CSharpCallCPluseDll</a></p><h1 id=參考資料>參考資料</h1><p><a href=http://swaywang.blogspot.com/2012/11/cnative-dlls-pinvoke.html>C#呼叫Native DLLs (P/Invoke)</a></p><p><a href=https://oblivious9.pixnet.net/blog/post/206689885-c%2B%2B-%E8%A3%BD%E4%BD%9Cdll%E7%B5%A6c%23%E4%BD%BF%E7%94%A8>C++ 製作DLL給C#使用</a></p></div><div class=post-footer></div></article></main></body></html>